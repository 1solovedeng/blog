<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>声明-2025-5-15</title>
      <link href="/posts/%E5%A3%B0%E6%98%8E-2025-5-15/"/>
      <url>/posts/%E5%A3%B0%E6%98%8E-2025-5-15/</url>
      
        <content type="html"><![CDATA[<h1 id="声明-2025-5-15"><a href="#声明-2025-5-15" class="headerlink" title="声明(2025-5-15)"></a>声明(2025-5-15)</h1><p>感谢大家一直以来对我的博客的关注与支持！</p><p>在过去的内容创作过程中，我逐渐意识到，部分文章在质量、深度和表达上仍有较大提升空间。作为一个持续学习和成长的个人创作者，我深感有责任对已有内容进行反思和优化。</p><p>因此，我决定对博客中部分文章进行重写和更新，以提升整体内容质量。这一过程可能需要一定的时间，在此期间，博客的更新频率可能会有所调整，敬请谅解。</p><ol><li><p><strong>内容质量升级计划</strong>  </p><ul><li>经自我审查，早期文章存在<strong>代码示例不足、技术解析深度不够</strong>等问题</li><li>将对历史文章进行全面重构，新增：<ul><li>🖼️ <strong>可视化流程图</strong>说明技术原理</li><li>💻 <strong>完整代码段+逐行注释解析</strong></li><li>🧩 <strong>典型应用场景</strong>及最佳实践</li></ul></li></ul></li><li><p><strong>阶段性更新调整</strong>  </p><ul><li>即日起延缓各种文章的发布，优先进行内容质量升级</li><li>每周六&#x2F;日将：<br>✅ 重制2-3篇旧文（含案例升级）<br>✅ 在<a href="https://github.com/1solovedeng">Github</a>同步开源代码片段</li></ul></li></ol><hr><p>✨ <strong>博客网址：</strong> <a href="https://solovedeng.top/">solovedeng.top</a><br>🎥 <strong>同步平台：</strong> 抖音 &#x2F; B站：solove等（将陆续更新相关内容）<br>🌟 <strong>欢迎关注：</strong> 微信公众号：Solove指针驿站</p>]]></content>
      
      
      <categories>
          
          <category> Statement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-3-无重复字符的最长子串（Longest Substring Without Repeating Characters）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）"><a href="#3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）" class="headerlink" title="3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/"><span style="color:#1E90FF;">3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color:#FFA500;">中等</span></h2><p>给定一个字符串 <code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;abcabcbb&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>3</code></span><br><strong>解释：</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;</code>，所以其长度为 <code>3</code>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;bbbbb&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>1</code></span><br><strong>解释：</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 <code>1</code>。</p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;pwwkew&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>3</code></span><br><strong>解释：</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 <code>3</code>，注意答案必须是子串长度。</p><hr><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h2><ul><li><span style="color:#2E8B57;"><code>0 &lt;= s.length &lt;= 5 * 10^4</code></span>  </li><li><span style="color:#2E8B57;"><code>s</code> 由英文字母、数字、符号和空格组成</span></li></ul><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><p><strong>思路：</strong><br>从字符串的每一个起始位置出发，依次向后扩展子串，同时使用一个布尔数组或集合来记录当前子串中出现过的字符，一旦遇到重复字符，则停止扩展，对比记录最长长度。该方法直观易懂，但效率较低。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">seen</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]]) <span class="keyword">break</span>;</span><br><span class="line">                seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]] = <span class="literal">true</span>;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(n^3)</code>  </li><li><strong>空间复杂度：</strong> <code>O(1)</code></li></ul><hr><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a><span style="color:#8B0000;">方法二：滑动窗口</span></h2><p><strong>思路：</strong><br>维护一个滑动窗口，用两个指针 <code>l</code>（左边界）和 <code>r</code>（右边界），以及一个哈希数组记录窗口内字符出现次数。当右指针包含的新字符导致重复时，就移动左指针并更新计数，直到窗口中不再有重复字符，同时每次都更新最大窗口长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            ++count[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (count[s[r]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --count[s[l]];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(n)</code>  </li><li><strong>空间复杂度：</strong> <code>O(1)</code></li></ul><hr><h2 id="方法三：优化滑动窗口（记录上次出现位置）"><a href="#方法三：优化滑动窗口（记录上次出现位置）" class="headerlink" title="方法三：优化滑动窗口（记录上次出现位置）"></a><span style="color:#8B0000;">方法三：优化滑动窗口（记录上次出现位置）</span></h2><p><strong>思路：</strong><br>使用数组 <code>lastSeen</code> 记录每个字符上次出现的索引，当遍历到字符 <code>s[i]</code> 时，若 <code>lastSeen[s[i]]</code> 在当前窗口内，则直接将左边界 <code>start</code> 移动到 <code>lastSeen[s[i]] + 1</code>，这样无需逐步移动指针，窗口始终保持无重复状态，同时更新最长长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastSeen</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            start = <span class="built_in">max</span>(start, lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] + <span class="number">1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">            lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(n)</code>  </li><li><strong>空间复杂度：</strong> <code>O(1)</code></li></ul><hr><h2 id="作者想说的话："><a href="#作者想说的话：" class="headerlink" title="作者想说的话："></a><span style="color:#000080;">作者想说的话：</span></h2><p>这道题是字符串滑动窗口的经典示例，推荐掌握<strong>方法三</strong>作为最佳方案。</p><p>更多字符串变体练习：  </p><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/"><span style="color:#2E8B57;"><code>最长回文子串（Longest Palindromic Substring）</code></span></a>  </li><li><a href="https://leetcode.cn/problems/minimum-window-substring/"><span style="color:#2E8B57;"><code>最小覆盖子串（Minimum Window Substring）</code></span></a>  </li><li><a href="https://leetcode.cn/problems/permutation-in-string/"><span style="color:#2E8B57;"><code>字符串的排列（Permutation in String）</code></span></a>  </li><li><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/"><span style="color:#2E8B57;"><code>最长重复字符替换（Longest Repeating Character Replacement）</code></span></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣-2-两数相加（Add-Two-Numbers）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加（Add-Two-Numbers）"><a href="#2-两数相加（Add-Two-Numbers）" class="headerlink" title="2. 两数相加（Add Two Numbers）"></a><a href="https://leetcode.cn/problems/add-two-numbers/"><span style="color:#1E90FF;">2. 两数相加（Add Two Numbers）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color: #FFAE42;">中等</span></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><hr><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h2><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[7,0,8]</code></span><br><strong>解释：</strong> 342 + 465 &#x3D; 807</p><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h2><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [0]</code>, <code>l2 = [0]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[0]</code></span></p><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h2><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [9,9,9,9,9,9,9]</code>, <code>l2 = [9,9,9,9]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[8,9,9,9,0,0,0,1]</code></span><br><strong>解释：</strong> 9999999 + 9999 &#x3D; 10009998</p><hr><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h2><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内  </li><li><code>0 &lt;= Node.val &lt;= 9</code>  </li><li>题目数据保证列表表示的数字不含前导零</li></ul><hr><h2 id="方法一：模拟加法（推荐）"><a href="#方法一：模拟加法（推荐）" class="headerlink" title="方法一：模拟加法（推荐）"></a><span style="color:#8B0000;">方法一：模拟加法（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(max(m, n))</code></li><li><strong>空间复杂度：</strong> <code>O(max(m, n))</code></li></ul><hr><h2 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a><span style="color:#8B0000;">方法二：递归实现</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">add</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        node-&gt;next = <span class="built_in">add</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>, l2 ? l2-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(max(m, n))</code></li><li><strong>空间复杂度：</strong> <code>O(max(m, n))</code>（递归栈空间）</li></ul><hr><h2 id="方法三：使用栈（适用于正序存储）"><a href="#方法三：使用栈（适用于正序存储）" class="headerlink" title="方法三：使用栈（适用于正序存储）"></a><span style="color:#8B0000;">方法三：使用栈（适用于正序存储）</span></h2><blockquote><p>虽然本题输入是逆序，但这个方法适用于变体题目：<strong>正序存储的链表相加</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将逆序链表反转为正序</span></span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123; s<span class="number">1.</span><span class="built_in">push</span>(l1-&gt;val); l1 = l1-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123; s<span class="number">2.</span><span class="built_in">push</span>(l2-&gt;val); l2 = l2-&gt;next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 栈法加法</span></span><br><span class="line">        <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>() || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = s<span class="number">1.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> y = s<span class="number">2.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            node-&gt;next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果反转回逆序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> <code>O(m + n)</code></li><li><strong>空间复杂度：</strong> <code>O(m + n)</code>（栈空间）</li></ul><hr><h2 id="作者想说的话："><a href="#作者想说的话：" class="headerlink" title="作者想说的话："></a><span style="color:#000080;">作者想说的话：</span></h2><p>这道题是链表与模拟结合的经典题。建议掌握 方法一（迭代）作为首选方案，同时了解递归与栈的思想，对处理不同链表题非常有帮助。</p><p>推荐拓展练习：<a href="https://leetcode.cn/problems/add-two-numbers-ii/">力扣 445. 两数相加 II</a>（正序版本）。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>声明(2025-5-13)</title>
      <link href="/posts/%E5%A3%B0%E6%98%8E-2025-5-13/"/>
      <url>/posts/%E5%A3%B0%E6%98%8E-2025-5-13/</url>
      
        <content type="html"><![CDATA[<h1 id="声明-2025-5-13"><a href="#声明-2025-5-13" class="headerlink" title="声明(2025-5-13)"></a>声明(2025-5-13)</h1><p>感谢各位朋友对我的博客关注与支持！在此声明：  </p><ol><li><p><strong>初步探索阶段已完成</strong>  </p><ul><li>博客的整体框架、栏目结构及基础功能均已搭建完成。  </li><li>内容组织方式、更新流程也已基本稳定，进入持续运营阶段。</li></ul></li><li><p><strong>接下来将争取每日更新</strong>  </p><ul><li>博客将持续发布原创内容，涵盖技术分享、学习笔记、生活感悟等。  </li><li>保持高频率输出，努力做到<strong>日更不断更</strong>。</li></ul></li><li><p><strong>希望大家喜欢并推荐给更多人</strong>  </p><ul><li>如果你觉得内容不错，欢迎<strong>点赞、收藏、分享</strong>。  </li><li>也请多多<strong>推荐给你的朋友、同学或同行</strong>，让更多人看到这些内容。</li></ul></li><li><p><strong>欢迎相互交流，共同进步</strong>  </p><ul><li>无论你是路过的访客还是长期关注的朋友，都欢迎在评论区留言互动。  </li><li>你也可以通过<strong>邮箱、抖音、B站等平台</strong>联系我，交流经验、提出建议或参与讨论。</li></ul></li></ol><hr><p>✨ <strong>博客网址：</strong> <a href="https://solovedeng.top/">solovedeng.top</a><br>🎥 <strong>同步平台：</strong> 抖音 &#x2F; B站：solove等（将陆续更新相关内容）<br>🌟 <strong>欢迎关注：</strong> 微信公众号：Solove指针驿站<br>📆 <strong>更新承诺：</strong> <strong>每日更新</strong>，持续优化，只为与你共同成长。  </p>]]></content>
      
      
      <categories>
          
          <category> Statement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目推荐-SDL太空战机射击游戏(SDLShooter)</title>
      <link href="/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/"/>
      <url>/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/</url>
      
        <content type="html"><![CDATA[<h1 align="center" style="color:#1E90FF;">🚀 推荐项目：SDL 太空战机射击游戏</h1><hr><h2 id="🧭-项目简介"><a href="#🧭-项目简介" class="headerlink" title="🧭 项目简介"></a>🧭 项目简介</h2><ul><li><strong>项目名称</strong>：<strong>SDLShooter</strong>（太空战机射击游戏）  </li><li><strong>教程主页</strong>：👉 <a href="https://cppgamedev.top/courses/sdl-space-shooter">https://cppgamedev.top/courses/sdl-space-shooter</a>  </li><li><strong>源项目仓库</strong>：🔗 <a href="https://github.com/WispSnow/SDLShooter">github.com&#x2F;WispSnow&#x2F;SDLShooter</a>  </li><li><strong>我的个性化版本(持续学习并更新中)</strong>：✨ <a href="https://github.com/1solovedeng/SDLShooter">github.com&#x2F;1solovedeng&#x2F;SDLShooter</a>  </li><li><strong>开源协议</strong>：🆓 <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0-1.0（公有领域，无需署名）</a></li></ul><hr><h2 id="🧑‍💻-为什么推荐这个项目给初学者？"><a href="#🧑‍💻-为什么推荐这个项目给初学者？" class="headerlink" title="🧑‍💻 为什么推荐这个项目给初学者？"></a>🧑‍💻 <span style="color:#FF6600;"><strong>为什么推荐这个项目给初学者？</strong></span></h2><ol><li>🛠️ <span style="color:#00BFFF;"><strong>跨平台、零门槛</strong></span>：基于 SDL2&#x2F;SDL3，支持 Windows &#x2F; Linux &#x2F; macOS，全平台开发无压力。  </li><li>🧩 <span style="color:#32CD32;"><strong>模块化教程</strong></span>：每个章节配有文字+视频教学，对应源码分支一一匹配，方便跟进。  </li><li>🔍 <span style="color:#FF1493;"><strong>实战 + 原理结合</strong></span>：涵盖图形渲染、输入处理、碰撞检测、资源加载等游戏开发核心。  </li><li>📦 <span style="color:#FFA500;"><strong>内置丰富素材</strong></span>：内含音乐、音效、精灵图、爆炸特效、字体，无需再东找西找。  </li><li>🌱 <span style="color:#8A2BE2;"><strong>超自由授权</strong></span>：CC0 许可可商用可二创，想怎么玩都行！</li></ol><hr><h2 id="🌟-项目亮点展示"><a href="#🌟-项目亮点展示" class="headerlink" title="🌟 项目亮点展示"></a>🌟 <span style="color:#DC143C;"><strong>项目亮点展示</strong></span></h2><ul><li>🎮 <span style="color:#FF4500;"><strong>完整功能</strong></span>：主菜单、敌机 AI、爆炸特效、子弹发射、BGM 等典型系统一应俱全。  </li><li>🖼️ <span style="color:#1E90FF;"><strong>高质量素材包整合</strong></span>：以下资源全部 CC0 免费可用：  <ul><li>飞机素材：<a href="https://anim86.itch.io/space-shoter-starter-pack">anim86.itch.io</a>  </li><li>UI 血条：<a href="https://doshrosity.itch.io/32x32-health-ui">doshrosity.itch.io</a>  </li><li>音效包：<a href="https://enprimer.itch.io/spaceship-sound-effects-pack">enprimer.itch.io</a>  </li><li>音乐包：<a href="https://leohpaz.itch.io/space-music-pack">leohpaz.itch.io</a>  </li><li>像素字体：<a href="https://timothyqiu.itch.io/vonwaon-bitmap">timothyqiu.itch.io</a>  </li><li>爆炸特效：<a href="https://ansimuz.itch.io/explosion-animations-pack">ansimuz.itch.io</a></li></ul></li><li>🧠 <span style="color:#20B2AA;"><strong>面向学习设计</strong></span>：每章节分支 <code>chapter-x</code> 可一键跳转当前进度，边学边练最舒适。  </li><li>💡 <span style="color:#FF69B4;"><strong>高度可扩展性</strong></span>：源码清晰，便于添加关卡系统、武器升级、多玩家或联网功能。</li></ul><hr><h2 id="🛠️-环境配置指南"><a href="#🛠️-环境配置指南" class="headerlink" title="🛠️ 环境配置指南"></a>🛠️ 环境配置指南</h2><h3 id="🔵-Linux（Ubuntu）"><a href="#🔵-Linux（Ubuntu）" class="headerlink" title="🔵 Linux（Ubuntu）"></a>🔵 Linux（Ubuntu）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install cmake libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev</span><br></pre></td></tr></table></figure><h3 id="🍎-macOS（基于-Homebrew）"><a href="#🍎-macOS（基于-Homebrew）" class="headerlink" title="🍎 macOS（基于 Homebrew）"></a>🍎 macOS（基于 Homebrew）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake sdl2 sdl2_image sdl2_mixer sdl2_ttf</span><br></pre></td></tr></table></figure><h3 id="🪟-Windows（推荐使用-Visual-Studio-或-VSCode）"><a href="#🪟-Windows（推荐使用-Visual-Studio-或-VSCode）" class="headerlink" title="🪟 Windows（推荐使用 Visual Studio 或 VSCode）"></a>🪟 Windows（推荐使用 Visual Studio 或 VSCode）</h3><ol><li>安装 <strong>Visual Studio 生成工具</strong>（或使用 VS2022）。  </li><li>下载 SDL2、SDL2_image、SDL2_mixer、SDL2_ttf 的 MSVC 版本。  </li><li>将 SDL <code>主文件夹路径</code> 与 <code>lib\x64</code> 添加到系统 PATH。  </li><li>使用 CMake 构建项目即可。</li></ol><hr><h2 id="🚀-快速开始（命令行方式）"><a href="#🚀-快速开始（命令行方式）" class="headerlink" title="🚀 快速开始（命令行方式）"></a>🚀 快速开始（命令行方式）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/WispSnow/SDLShooter.git</span><br><span class="line"><span class="built_in">cd</span> SDLShooter</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./SDLShooter</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>提示</strong>：也可以用 Visual Studio、CLion、VSCode 等 IDE 直接打开项目。</p></blockquote><hr><h2 id="🔧-我的个性版本（持续学习并更新中）"><a href="#🔧-我的个性版本（持续学习并更新中）" class="headerlink" title="🔧 我的个性版本（持续学习并更新中）"></a>🔧 我的个性版本（持续学习并更新中）</h2><p>📌 欢迎查看我的个性化实现和改进版：<a href="https://github.com/1solovedeng/SDLShooter">https://github.com/1solovedeng/SDLShooter</a></p><hr><h2 id="🎯-适合谁？"><a href="#🎯-适合谁？" class="headerlink" title="🎯 适合谁？"></a>🎯 <span style="color:#00CED1;"><strong>适合谁？</strong></span></h2><ul><li>📚 C++ 初学者，希望快速建立完整项目经验  </li><li>🎮 对游戏开发感兴趣，想了解从零构建一个 2D 游戏的全过程  </li><li>💡 想基于 SDL 引擎进行拓展开发，如 AI、粒子、物理、地图编辑器等</li></ul><hr><h2 id="🏁-总结"><a href="#🏁-总结" class="headerlink" title="🏁 总结"></a>🏁 总结</h2><p>🎉 <strong>SDLShooter</strong> 是一个集实战、学习、素材、授权于一体的超强新手项目。<br>🎯 如果你正在寻找一个能立刻投入实践、同时能打通 SDL 知识体系的项目，它就是你的最佳选择！<br>🛠️ 动手开发，<span style="color:#32CD32;"><strong>从这款射击游戏开始你的 C++ 游戏开发之路！</strong></span></p><hr><h2 align="center" style="color:#FF8C00;">🌌 Happy Coding & Enjoy Shooting! 🌌</h2>]]></content>
      
      
      <categories>
          
          <category> ProjectPicks </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣-1.两数之和（Two Sum）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和（Two-Sum）"><a href="#1-两数之和（Two-Sum）" class="headerlink" title="1. 两数之和（Two Sum）"></a><a href="https://leetcode.cn/problems/two-sum/"><span style="color:#1E90FF;">1. 两数之和（Two Sum）</span></a></h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a><span style="color:#228B22;">简单</span></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值 <code>target</code> 的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>nums = [2,7,11,15]</code>, <code>target = 9</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[0,1]</code></span><br><strong>解释：</strong> 因为 <span style="color:#DAA520;"><code>nums[0] + nums[1] == 9</code></span>，返回 <span style="color:#DAA520;"><code>[0, 1]</code></span>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>nums = [3,2,4]</code>, <code>target = 6</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[1,2]</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>nums = [3,3]</code>, <code>target = 6</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[0,1]</code></span></p><hr><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h3><ul><li><span style="color:#2E8B57;"><code>2 &lt;= nums.length &lt;= 10^4</code></span>  </li><li><span style="color:#2E8B57;"><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></span>  </li><li><span style="color:#2E8B57;"><code>-10^9 &lt;= target &lt;= 10^9</code></span>  </li><li><span style="color:#2E8B57;">只会存在一个有效答案</span></li></ul><hr><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a><span style="color:#FF8C00;">进阶：</span></h3><p>你可以想出一个时间复杂度小于 <span style="color:#2F4F4F;"><code>O(n^2)</code></span> 的算法吗？</p><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">47ms</span>，击败 <span style="color:#8B0000;">28.79%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">13.80MB</span>，击败 <span style="color:#8B0000;">83.42%</span></li></ul><p><strong>思路：</strong><br>嵌套两个循环，枚举数组中每一对 <code>(i, j)</code>，检查 <span style="color:#DAA520;"><code>nums[i] + nums[j] == target</code></span> 时立即返回下标。不使用额外空间，直观易实现，但在 n 较大时性能迅速下降。</p><hr><h2 id="方法二：二次遍历哈希表"><a href="#方法二：二次遍历哈希表" class="headerlink" title="方法二：二次遍历哈希表"></a><span style="color:#8B0000;">方法二：二次遍历哈希表</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 第一次遍历：填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lookup[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次遍历：找补数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> c = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">7ms</span>，击败 <span style="color:#8B0000;">43.89%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">15.74MB</span>，击败 <span style="color:#8B0000;">5.38%</span></li></ul><hr><h2 id="方法三：一次遍历哈希表（相对最优解）"><a href="#方法三：一次遍历哈希表（相对最优解）" class="headerlink" title="方法三：一次遍历哈希表（相对最优解）"></a><span style="color:#8B0000;">方法三：一次遍历哈希表（相对最优解）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主体函数：一次遍历哈希表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;              <span class="comment">// 准备一个空的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 遍历每个元素</span></span><br><span class="line">            <span class="type">int</span> complement = target - nums[i];       <span class="comment">// 计算补数</span></span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(complement);       <span class="comment">// 在哈希表中查找补数</span></span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>()) &#123;               <span class="comment">// 若找到了</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;              <span class="comment">// 立即返回“补数的下标 + 当前下标”</span></span><br><span class="line">            &#125;</span><br><span class="line">            lookup[nums[i]] = i;                     <span class="comment">// 否则，将当前元素插入哈希表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">0ms</span>，击败 <span style="color:#8B0000;">100.00%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">14.55MB</span>，击败 <span style="color:#8B0000;">45.96%</span></li></ul><hr><h2 id="复杂度对比"><a href="#复杂度对比" class="headerlink" title="复杂度对比"></a>复杂度对比</h2><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><span style="color:#8B0000;">暴力枚举</span></td><td><span style="color:#8B0000;">O(n^2)</span></td><td><span style="color:#8B0000;">O(1)</span></td></tr><tr><td><span style="color:#8B0000;">二次遍历哈希表</span></td><td><span style="color:#8B0000;">O(n)</span></td><td><span style="color:#8B0000;">O(n)</span></td></tr><tr><td><span style="color:#8B0000;">一次遍历哈希表</span></td><td><span style="color:#8B0000;">平均 O(n)，最坏 O(n^2)</span></td><td><span style="color:#8B0000;">O(n)</span></td></tr></tbody></table><hr><h2 id="作者想说的话："><a href="#作者想说的话：" class="headerlink" title="作者想说的话："></a><span style="color:#000080;">作者想说的话：</span></h2><p>“两数之和（Two Sum）” 是经典入门题，这三种解法体现了解题思路从易到优的演进。  </p><p>过程中可以体会到「空间换时间」的威力，也认识到代码简洁性的重要性。  </p><p>希望本文能帮助你快速上手，并在面试或项目中灵活应用。  </p><p>下一步可以尝试 <a href="https://leetcode.cn/problems/3sum/"><span style="color:#2E8B57;"><code>Three Sum</code></span></a>、<a href="https://leetcode.cn/problems/subarray-sum-equals-k/"><span style="color:#2E8B57;"><code>Subarray Sum</code></span></a><br>等变体，欢迎在评论区交流你的思路。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实用工具-Dev-C++</title>
      <link href="/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/"/>
      <url>/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于 2025-5-18</p></blockquote><h1 id="🛠️-推荐工具：Dev-C"><a href="#🛠️-推荐工具：Dev-C" class="headerlink" title="🛠️ 推荐工具：Dev-C++"></a>🛠️ 推荐工具：Dev-C++</h1><p><strong>Dev-C++</strong> 是一款轻量级、免费开源的 C&#x2F;C++ 集成开发环境（IDE），内置 GCC 编译器，适用于 Windows 系统。其界面简洁、操作直观，尤其适合 C&#x2F;C++ 初学者使用。</p><h2 id="✅-主要特点"><a href="#✅-主要特点" class="headerlink" title="✅ 主要特点"></a>✅ 主要特点</h2><ul><li><strong>语法高亮与代码补全</strong>：支持语法高亮显示和自动代码补全，减少编辑错误，提高编码效率。</li><li><strong>多语言支持</strong>：提供简体中文、繁体中文、英语等多种语言界面，方便不同用户使用。</li><li><strong>内置调试功能</strong>：集成调试器，支持断点设置、变量监视等基本调试操作。</li><li><strong>适合初学者</strong>：操作简便，学习成本低，是学习 C&#x2F;C++ 编程的理想工具。</li><li><strong>集成多种工具</strong>：集合了 MinGW 中的 GCC 编译器、GDB 调试器和 AStyle 格式整理器等自由软件。</li></ul><h2 id="📥-下载地址"><a href="#📥-下载地址" class="headerlink" title="📥 下载地址"></a>📥 下载地址</h2><ul><li>阿里云盘： <a href="https://www.alipan.com/s/JDbA6mR8iVm">点击下载</a></li><li>百度网盘： <a href="https://pan.baidu.com/s/1S4FZFabzbIL2nK_bfe6MNw?pwd=nura">点击下载</a>  <blockquote><p>提取码：<code>nura</code></p></blockquote></li><li>夸克网盘： <a href="https://pan.quark.cn/s/5176261faeae">点击下载</a></li></ul><blockquote><p>⚠️ 如果链接失效，请在评论区留言，我们会及时更新。感谢您的支持与指正！</p></blockquote><h2 id="📚-安装与使用教程"><a href="#📚-安装与使用教程" class="headerlink" title="📚 安装与使用教程"></a>📚 安装与使用教程</h2><ul><li><a href="https://www.dotcpp.com/course/338">Dev-C++ 下载与安装图文教程</a></li><li><a href="https://blog.csdn.net/bigzql/article/details/109349382">Dev-C++ 安装及使用方法教程</a></li></ul><hr><h2 id="⚠️-声明"><a href="#⚠️-声明" class="headerlink" title="⚠️ 声明"></a>⚠️ <strong>声明</strong></h2><p><strong>Dev-C++</strong> 因多年未获持续更新，其核心工具链和功能已显过时，不再适合中大型或需现代 C&#x2F;C++ 特性（如 C++17&#x2F;20、模块化构建、内置包管理等）的项目开发。  </p><blockquote><ul><li><strong>官方原始版</strong>（Bloodshed Software）自 2005 年 2 月 22 日起即停止活跃维护，后续开发主要停滞不前，存在大量已知缺陷难以修复。</li><li><strong>Embarcadero 维护的最新版</strong>（最新 6.3 版本）最后发布于 2021 年 1 月 30 日，且最近一次更新记录为 2021 年 5 月 19 日，距今已逾四年。</li></ul></blockquote><p><strong>建议</strong>  </p><blockquote><ul><li><strong>仅限入门学习</strong>：Dev-C++ 界面简洁、操作直观，适合作为 C&#x2F;C++ 新手的入门练习环境。  </li><li><strong>深入研究</strong>：文中详述的环境配置、项目管理与调试技巧，建议仅用于学习参考及历史研究，若进行实际开发，请优先选择更现代的 IDE，如 <strong>Visual Studio</strong>, <strong>CLion</strong>, <strong>Code::Blocks</strong>, 或基于 <strong>VS Code</strong> 的开发环境。</li></ul></blockquote><hr><h2 id="⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点："><a href="#⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点：" class="headerlink" title="⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点："></a><strong>⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点：</strong></h2><p>① 编辑器默认编码为 ANSI，与源文件或系统不匹配<br>② Console 窗口默认 Code Page 非 UTF-8，导致输出无法正确解码<br>③ 系统语言&#x2F;区域设置不当，可能影响文件打开与显示  </p><p>下面汇总几种常用且高效的解决方案，您可按需任选或组合使用。</p><hr><h2 id="①-更改编辑器默认编码"><a href="#①-更改编辑器默认编码" class="headerlink" title="① 更改编辑器默认编码"></a>① 更改编辑器默认编码</h2><p>a. 打开 Dev-C++，依次点击 <strong>Tools → Editor Options</strong>，在 <strong>General</strong>（或 <strong>Code Generation</strong>）选项卡中，将 <strong>Character set</strong> 从 <strong>ANSI</strong> 改为 <strong>UTF-8</strong> 并确认。<br>b. 关闭当前编辑的文件后重新打开，即可让编辑器以 UTF-8 模式加载和保存文件。</p><hr><h2 id="②-源文件另存为-UTF-8"><a href="#②-源文件另存为-UTF-8" class="headerlink" title="② 源文件另存为 UTF-8"></a>② 源文件另存为 UTF-8</h2><p>a. 在 Dev-C++ 中打开源文件，点击 <strong>File → Save As…</strong><br>b. 在保存对话框的编码选项中，选择 <strong>UTF-8</strong>（无 BOM）后保存。<br>c. 若批量转换，可使用 Notepad++：打开文件 → <strong>Encoding → Convert to UTF-8</strong> → 保存。</p><hr><h2 id="③-利用记事本或-Notepad-转码"><a href="#③-利用记事本或-Notepad-转码" class="headerlink" title="③ 利用记事本或 Notepad++ 转码"></a>③ 利用记事本或 Notepad++ 转码</h2><p>a. <strong>记事本法</strong>：  </p><ul><li>右键目标 <code>.cpp</code>&#x2F;<code>.h</code> 文件 → <strong>打开方式 → 记事本</strong>  </li><li>在记事本中点击 <strong>文件 → 另存为</strong>，选择 <strong>ANSI</strong> 编码保存（覆盖或另存）  </li><li>再用 Dev-C++ 打开，强制以 ANSI 读取，常能规避乱码</li></ul><p>b. <strong>Notepad++ 法</strong>：  </p><ul><li>用 Notepad++ 打开源码 → <strong>Encoding → Convert to UTF-8</strong>（注意非“Encode in UTF-8”）  </li><li>保存后再用 Dev-C++ 正常打开编译</li></ul><hr><h2 id="④-设置-Console-窗口编码"><a href="#④-设置-Console-窗口编码" class="headerlink" title="④ 设置 Console 窗口编码"></a>④ 设置 Console 窗口编码</h2><p>a. 在 Windows 控制台中手动切换：  </p><blockquote><p>chcp 65001</p></blockquote><p>   使当前会话使用 UTF-8 Code Page<br>b. 或修改注册表，永久生效：  </p><ul><li><p>打开 <strong>Regedit</strong>，定位到  </p><blockquote><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\Autorun</p></blockquote><p>新建&#x2F;修改字符串值为：  </p><blockquote><p>@chcp 65001&gt;nul</p></blockquote><p>以后每次打开控制台都会自动切换到 UTF-8</p></li></ul><hr><h2 id="⑤-在代码中显式设置"><a href="#⑤-在代码中显式设置" class="headerlink" title="⑤ 在代码中显式设置"></a>⑤ 在代码中显式设置</h2><p> 在程序入口处调用 Windows API：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="强制控制台以-UTF-8-解码输出"><a href="#强制控制台以-UTF-8-解码输出" class="headerlink" title="   强制控制台以 UTF-8 解码输出"></a>   强制控制台以 UTF-8 解码输出</h2><h2 id="⑥-检查系统语言与区域设置"><a href="#⑥-检查系统语言与区域设置" class="headerlink" title="⑥ 检查系统语言与区域设置"></a>⑥ 检查系统语言与区域设置</h2><p>a. 进入 <strong>控制面板 → 语言和区域设置 → 管理语言设置</strong><br>b. 将“非 Unicode 程序的语言”改为 <strong>中文（简体，中国）</strong>，重启生效<br>c. 确保系统区域、字体均支持中文显示</p><hr><blockquote><p>以上方法可单独或组合使用，通常先保证编辑器和源文件均为 UTF-8，再调整控制台 Code Page，即可彻底解决 Dev-C++ 中文乱码问题。</p></blockquote><hr><h1 id="✅Dev-C-使用方法："><a href="#✅Dev-C-使用方法：" class="headerlink" title="✅Dev-C++使用方法："></a>✅Dev-C++使用方法：</h1><h2 id="1-界面与工作区布局"><a href="#1-界面与工作区布局" class="headerlink" title="1. 界面与工作区布局"></a>1. 界面与工作区布局</h2><p><img src="https://raw.githubusercontent.com/Embarcadero/Dev-Cpp/master/Source/Images/screenshot800x600.png" alt="Dev-C++ 主界面示例"><br><em>图：Dev-C++ 典型代码编辑与输出窗口布局</em>  </p><ol><li><strong>代码编辑区</strong>：左侧显示项目文件树，右侧显示代码编辑窗口。您可以通过拖动标签页，自由切换不同文件。</li><li><strong>输出与调试区</strong>：底部集成 Console 窗口，运行、编译、调试的所有输出都会在此展示，支持清屏和滚动查看。</li><li><strong>工具栏与菜单</strong>：常用操作按钮集中于顶部，包括新建、打开、保存、编译、调试、运行等，鼠标悬停可查看快捷键提示。</li></ol><h2 id="2-项目管理与构建流程"><a href="#2-项目管理与构建流程" class="headerlink" title="2. 项目管理与构建流程"></a>2. 项目管理与构建流程</h2><h3 id="2-1-新建项目"><a href="#2-1-新建项目" class="headerlink" title="2.1 新建项目"></a>2.1 新建项目</h3><ol><li>打开 Dev-C++ 后，依次点击：</li></ol><blockquote><p>File → New → Project</p></blockquote><ol start="2"><li>在弹出的对话框中选择“Console Application”或“GUI Application”，按照向导填写项目名称与保存路径。</li></ol><h3 id="2-2-添加源文件、头文件"><a href="#2-2-添加源文件、头文件" class="headerlink" title="2.2 添加源文件、头文件"></a>2.2 添加源文件、头文件</h3><ul><li>在“Project”窗口右键项目名，选择 <strong>Add to Project → New File</strong>，即可创建新的 <code>.cpp</code> 或 <code>.h</code> 文件。</li><li>若想引入已有文件，则选择 <strong>Add to Project → Add Existing Item</strong>，浏览文件夹并选中即可。</li></ul><h3 id="2-3-编译与链接"><a href="#2-3-编译与链接" class="headerlink" title="2.3 编译与链接"></a>2.3 编译与链接</h3><ul><li>点击工具栏上的 <strong>Compile</strong> (编译) 按钮即可编译当前源文件。</li><li>点击 <strong>Run</strong> (运行) 按钮，Dev-C++ 会先自动编译并链接，然后在下方 Console 窗口中执行。</li><li>若需要只链接不运行，可在菜单中选择 <strong>Execute → Compile &amp; Run Options</strong>，取消“Run after compile”前的勾选。</li></ul><h2 id="3-高级调试技巧"><a href="#3-高级调试技巧" class="headerlink" title="3. 高级调试技巧"></a>3. 高级调试技巧</h2><p><img src="https://img.youtube.com/vi/R5zhpQW-MJk/maxresdefault.jpg" alt="调试断点与变量监视"><br><em>图：设置断点与在“Watches”窗口监视变量值</em></p><ol><li><strong>断点管理</strong>：在代码编辑区左侧行号栏单击，可新增&#x2F;删除断点。</li><li><strong>单步执行</strong>：使用 <strong>Step Into (F7)</strong>、<strong>Step Over (F8)</strong> 等功能逐行跟踪。</li><li><strong>变量监视</strong>：在“Watches”窗口右键 → <strong>Insert Watch</strong>，输入变量名，可动态观察其值变化。</li><li><strong>调用堆栈</strong>：在断点处暂停时，点击“Call Stack”选项卡查看函数调用顺序，快速定位问题源头。</li></ol><h2 id="4-插件与扩展：DevPaks-管理"><a href="#4-插件与扩展：DevPaks-管理" class="headerlink" title="4. 插件与扩展：DevPaks 管理"></a>4. 插件与扩展：DevPaks 管理</h2><ol><li>打开 <strong>Tools → Package Manager</strong>。</li><li>在“Available”选项卡中搜索并安装常用 DevPaks，如：<ul><li>`gtkmm-devpack`：GTK+ C++ 接口支持</li><li>`SDL2-devpack`：简单跨平台多媒体与游戏开发库</li><li>`mysql-devpack`：MySQL 数据库接口</li></ul></li><li>选中目标 DevPak，点击 <strong>Install</strong> 即可一键集成对应头文件和库。</li></ol><blockquote><p><strong>Tip</strong>：若官方仓库中未找到，您也可从 <a href="https://sourceforge.net/projects/devpaks/">SourceForge DevPaks 列表</a> 下载并安装。</p></blockquote><h2 id="5-性能优化与编译选项"><a href="#5-性能优化与编译选项" class="headerlink" title="5. 性能优化与编译选项"></a>5. 性能优化与编译选项</h2><ul><li><strong>Optimization level</strong> (<code>-O0</code>&#x2F;<code>-O1</code>&#x2F;<code>-O2</code>&#x2F;<code>-O3</code>): 开发阶段建议使用 <code>-O0</code> 便于调试；发布阶段可切换到 <code>-O2</code> 或 <code>-O3</code>，提升执行效率。</li><li><strong>Language standard</strong>：支持选择 <code>ISO C++11</code>、<code>ISO C++14</code>、<code>GNU C++17</code> 等，确保与现代编译特性兼容。</li><li><strong>Link-time optimization</strong> (LTO)：启用可在链接阶段进一步优化。</li></ul><h2 id="6-常见问题与解决方案"><a href="#6-常见问题与解决方案" class="headerlink" title="6. 常见问题与解决方案"></a>6. 常见问题与解决方案</h2><table><thead><tr><th>问题描述</th><th>解决方法</th></tr></thead><tbody><tr><td>编译时报 “cannot find -lmingw32”</td><td>检查 MinGW 路径：<code>Tools → Compiler Options → Directories → Libraries</code> 中添加 MinGW 安装目录下的 <code>lib</code></td></tr><tr><td>控制台汉字显示乱码</td><td>右键 Console → Properties → Font 选择 “新宋体” 或 “Consolas”，并确保文件以 UTF-8 编码保存</td></tr><tr><td>插件安装后 IDE 无法启动</td><td>删除 <code>%AppData%\\Dev-Cpp\\</code> 下的配置文件或重新安装对应 DevPak</td></tr><tr><td>调试时无法进入标准库函数</td><td>在 <strong>Project Options → Debugging</strong> 中勾选 “Debug Standard Libraries”</td></tr></tbody></table><h2 id="7-实战案例：使用-OpenCV-进行图像处理"><a href="#7-实战案例：使用-OpenCV-进行图像处理" class="headerlink" title="7. 实战案例：使用 OpenCV 进行图像处理"></a>7. 实战案例：使用 OpenCV 进行图像处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="built_in">imwrite</span>(<span class="string">&quot;output.jpg&quot;</span>, gray);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>安装 <code>opencv-devpack</code>。</li><li>新建 Console 项目，添加代码至 <code>main.cpp</code>。</li><li>链接参数：<code>-lopencv_core -lopencv_imgproc -lopencv_highgui</code>。</li><li>复制 OpenCV <code>bin</code> 下的 <code>.dll</code> 至可执行文件目录。</li><li>点击 <strong>Compile &amp; Run</strong>，查看生成的 <code>output.jpg</code>。</li></ol><h2 id="8-社区与学习资源"><a href="#8-社区与学习资源" class="headerlink" title="8. 社区与学习资源"></a>8. 社区与学习资源</h2><ul><li>官方论坛：Stack Overflow <a href="https://stackoverflow.com/questions/tagged/orwelldevcpp">orwelldevcpp</a></li><li>源码仓库:<a href="https://github.com/Embarcadero/Dev-Cpp">Embarcadero 官方托管（GitHub）</a></li><li>源码仓库:<a href="https://sourceforge.net/projects/orwelldevcpp/files/Source/">Orwell 版本源码快照（SourceForge）</a></li><li>书籍：《C++ Primer 中文版》、《Effective C++》系列、《OpenCV 图像处理实战》</li><li>视频教程：B站搜索“Dev-C++ 教程”</li></ul><h2 id="9-版本控制与协作"><a href="#9-版本控制与协作" class="headerlink" title="9. 版本控制与协作"></a>9. 版本控制与协作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用 Sourcetree、GitKraken 或命令行进行分支与合并管理。</li><li>通过 Pull Request 流程保证代码质量。</li></ul><h2 id="10-单元测试与质量保障"><a href="#10-单元测试与质量保障" class="headerlink" title="10. 单元测试与质量保障"></a>10. 单元测试与质量保障</h2><ul><li>安装 <code>gtest-devpack</code>，链接 <code>-lgtest -lgtest_main</code>。</li><li>示例测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="built_in">TEST</span>(MathTest, Add) &#123; <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span><span class="number">+3</span>,<span class="number">5</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>**argv)</span></span>&#123; testing::<span class="built_in">InitGoogleTest</span>(&amp;argc,argv); <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="11-静态分析与内存检测"><a href="#11-静态分析与内存检测" class="headerlink" title="11. 静态分析与内存检测"></a>11. 静态分析与内存检测</h2><ul><li><code>cppcheck --enable=all --inconclusive --std=c++17 src/</code></li><li>WSL&#x2F;Linux 下使用 <code>valgrind --leak-check=full ./your_executable</code></li></ul><h2 id="12-跨平台构建"><a href="#12-跨平台构建" class="headerlink" title="12. 跨平台构建"></a>12. 跨平台构建</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"><span class="keyword">add_executable</span>(MyApp main.cpp)</span><br></pre></td></tr></table></figure><ul><li>Windows 下 <code>cmake -G &quot;MinGW Makefiles&quot; . &amp;&amp; mingw32-make</code></li><li>WSL 下使用 Linux 编译链</li></ul><h2 id="13-自定义与自动化"><a href="#13-自定义与自动化" class="headerlink" title="13. 自定义与自动化"></a>13. 自定义与自动化</h2><h3 id="13-1-快捷键与宏"><a href="#13-1-快捷键与宏" class="headerlink" title="13.1 快捷键与宏"></a>13.1 快捷键与宏</h3><ul><li><strong>Tools → Editor Options → Keyboard</strong> 自定义快捷键</li><li><strong>Tools → Record Macro</strong> 录制并执行操作</li></ul><h3 id="13-2-构建脚本"><a href="#13-2-构建脚本" class="headerlink" title="13.2 构建脚本"></a>13.2 构建脚本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> /q bin\*</span><br><span class="line">devcpp.exe <span class="literal">-c</span> main.cpp <span class="literal">-o</span> bin\MyApp.exe</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="14-第三方插件与工具"><a href="#14-第三方插件与工具" class="headerlink" title="14. 第三方插件与工具"></a>14. 第三方插件与工具</h2><table><thead><tr><th>DevPak 名称</th><th>功能简介</th></tr></thead><tbody><tr><td>gtkmm-devpack</td><td>GTK+ C++ 图形界面支持</td></tr><tr><td>SDL2-devpack</td><td>跨平台多媒体与游戏开发</td></tr><tr><td>mysql-devpack</td><td>MySQL 数据库接口</td></tr><tr><td>boost-devpack</td><td>智能指针、正则等增强库</td></tr><tr><td>openssl-devpack</td><td>加密与安全通信支持</td></tr></tbody></table><p>可结合 Doxygen、ClangFormat、Bear 提升开发效率。</p><h2 id="15-安全注意事项"><a href="#15-安全注意事项" class="headerlink" title="15. 安全注意事项"></a>15. 安全注意事项</h2><ul><li>开启 <code>-fstack-protector-strong</code></li><li>严格边界检查，防止缓冲区溢出</li><li>发布开启 <code>-Wall -Wextra -Werror</code></li></ul><blockquote><p>本文从基础到高级全面覆盖 Dev-C++ 使用技巧与最佳实践，助您快速上手并精通。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PracticalTools </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
