<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人简历</title>
      <link href="/posts/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
      <url>/posts/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<style>:root{  /* 适配白底的深色/对比色方案 */  --page-bg: #ffffff;           /* 页面背景（白色） */  --text: #0f1724;              /* 主文本，深色，保证可读性 */  --muted: #334155;             /* 次要文字 */  --card-bg: #f8fafc;           /* 卡片浅灰（与白背景有分层） */  --border: #e6eef8;            /* 卡片边框色 */  --accent1: #0b69ff;          /* 主强调色（蓝） */  --accent2: #5b3cff;          /* 次强调色（紫） */  --accent3: #d43f4a;          /* 危险/提示色（红） */  --pill-bg: linear-gradient(90deg,#eef2ff,#f0f9ff);}/* 页面基础 */body{  background: var(--page-bg);  color: var(--text);  font-family: Inter, "PingFang SC", "Helvetica Neue", Arial, sans-serif;  line-height:1.6;  -webkit-font-smoothing:antialiased;  -moz-osx-font-smoothing:grayscale;  margin:0;  padding:0;}/* 封面 / 头部 */.cover{  display:flex;  gap:1rem;  align-items:center;  padding:1rem;  border-radius:12px;  background: linear-gradient(180deg, rgba(11,105,255,0.04), rgba(91,60,255,0.02));  margin-bottom:1rem;  border:1px solid var(--border);}.cover img{  width:110px;  height:110px;  border-radius:10px;  object-fit:cover;  box-shadow: 0 6px 20px rgba(16,24,40,0.04);  border:1px solid rgba(16,24,40,0.04);}.title {font-size:1.6rem; margin:0; color:var(--text); font-weight:700;}.badges{margin-top:6px;}.badge{  display:inline-block;  padding:0.18rem 0.6rem;  border-radius:999px;  margin-right:0.4rem;  font-weight:600;  font-size:0.85rem;  background: var(--pill-bg);  color: var(--muted);  border:1px solid rgba(16,24,40,0.04);}/* 卡片样式用于信息块 */.card{  background: var(--card-bg);  padding:0.9rem 1rem;  border-radius:10px;  margin:0.6rem 0;  border:1px solid var(--border);}/* 键值纵列布局（每项独占一行） */.kv-stacked {  display: flex;  flex-direction: column;  gap: 0.45rem; /* 行间距，可按需调整 */}.kv-item {  display: flex;  align-items: center;  gap: 0.6rem;  padding: 0.28rem 0; /* 每行内间距 */}/* 保持与你现有的 k / v 风格 */.k { min-width: 90px; color: var(--muted); font-weight:700; }.v { color: var(--text); font-weight:700; }/* 栏目与高亮 */.section-title{display:flex; align-items:center; gap:0.6rem; margin-top:1rem;}.section-title h2{margin:0; font-size:1.05rem; color:var(--accent2);}.highlight{color:var(--accent1); font-weight:700;}.pill{  background: linear-gradient(90deg, rgba(91,60,255,0.06), rgba(11,105,255,0.04));  padding:0.12rem 0.5rem;  border-radius:999px;  font-weight:700;  color:var(--accent2);  border:1px solid rgba(91,60,255,0.06);}/* 列表与小字 */.info-list{margin:0; padding-left:1rem; color:var(--text);}.info-list li{margin:0.35rem 0;}.small{font-size:0.92rem; color:var(--muted);}/* 响应式 */@media (max-width:760px){  .cover{flex-direction:column; align-items:flex-start;}  .cover img{width:100%; height:auto;}  .kv-item { gap: 0.4rem; }}</style><div class="cover">  <img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1757929620/38cfeac5c79c633fb5c005beb845dc1c_ulbsln.png" alt="cover">  <div>    <h1 class="title">杨皓晨 — <span class="highlight">个人简历</span></h1>    <div class="badges">      <span class="badge">本科 · 人工智能</span>      <span class="badge">商务拓展 / 销售等</span>    </div>  </div></div><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><div class="card">  <div class="kv-stacked">    <div class="kv-item"><div class="k">电话：</div><div class="v">(+86) 130-5131-1887</div></div>    <div class="kv-item"><div class="k">邮箱：</div><div class="v">solovedeng@gmail.com</div></div>    <div class="kv-item"><div class="k">户籍地：</div><div class="v">北京（石景山）</div></div>    <div class="kv-item"><div class="k">性别：</div><div class="v">男</div></div>    <div class="kv-item"><div class="k">出生：</div><div class="v">2004.07</div></div>    <div class="kv-item"><div class="k">政治面貌：</div><div class="v">群众</div></div>  </div></div><hr><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p><strong>北京信息科技大学（全日制本科） — <span class="highlight">人工智能</span></strong><br><small class="small">2022.09 — 2026.06</small></p><p><strong>主要课程：</strong> <span class="pill">自然语言处理</span>、<span class="pill">数据结构与算法</span>、<span class="pill">产品管理导论</span>、<span class="pill">数据库管理及应用</span>。</p><hr><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><p><strong>世界企业家资讯有限公司 — <span class="highlight">商务拓展实习生</span></strong><br><small class="small">北京 | 2025.07 — 2025.09</small></p><div class="card">岗位定位： 商务拓展、市场线索构建与售前支持。  <p><strong>主要职责：</strong><br>① <strong>市场调研与线索构建</strong>：使用 <span class="highlight">LinkedIn &#x2F; 企业库</span> 检索、整理并标注约 <span class="highlight">30–40 条潜在客户</span>，建立基础线索池。  </p><p>② <strong>外联与初步沟通</strong>：在主管指导下定制冷邮&#x2F;电话话术，主动联系目标客户并安排会议，支持并参与 <span class="highlight">5 次高层初谈或演示</span>。  </p><p>③ <strong>交付与跟进</strong>：跟进已落地项目进展，整理并提交周度运营与反馈报告（累计 <span class="highlight">8 份</span>），同步异常并推动问题闭环。  </p><p>④ <strong>Pipeline 管理</strong>：在 CRM 与 Excel 中维护商机 pipeline，按优先级筛选并推荐 <span class="highlight">8–10 条高潜商机</span>，供团队集中推进。  </p><p>⑤ <strong>技术支持</strong>：结合 AI 背景参与售前沟通，将技术能力转化为业务价值，支持方案演示与客户答疑。  </p><p><strong>阶段性成果：</strong><br>① 成功支持并促成多次高层会谈与演示，提升团队沟通效率。<br>② 优化线索筛选流程，使团队在短期内集中推进高潜商机。<br>③ 形成规范的周报模板，提升项目问题识别与闭环率。</p></div><hr><h2 id="校园项目"><a href="#校园项目" class="headerlink" title="校园项目"></a>校园项目</h2><p><strong>X光安检图像识别改良 — <span class="highlight">负责人</span></strong><br><small class="small">2024.09 — 2025.01</small></p><div class="card">项目背景： 提升 X 光安检系统对违禁物/可疑物的检测准确率并减少误报率，推动算法在试点场景落地。  <p><strong>本人主要职责：</strong><br>① <strong>技术—业务对接</strong>：与业务方沟通需求，明确落地场景与验收指标；负责落地准备与演示材料制作。  </p><p>② <strong>模型与工程</strong>：参与多任务检测与分割模型的设计、训练与性能评估，协助定位误报&#x2F;漏检根因并提出改进方案。  </p><p>③ <strong>市场与竞品调研</strong>：撰写市场&#x2F;客户画像，完成行业竞争与竞品分析报告，提出风险控制与产品落地建议。  </p><p>④ <strong>成果输出</strong>：编写量化分析与决策型报告，向技术与商务团队传达可执行的迭代建议，推动模型优化与试点合作落地。  </p><p><strong>项目成果：</strong><br>① 在试点数据上降低明显误报率。<br>② 提供针对特定场景的模型改良建议，并形成后续迭代计划。<br>③ 支持客户对接与演示，获得初步合作意向。</p></div><hr><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><ul><li><strong>机器学习与深度学习：</strong> 掌握监督&#x2F;无监督&#x2F;迁移学习，能构建分类、检测、分割模型。  </li><li><strong>数据清洗与分析：</strong> 熟练使用 <span class="highlight">Python (pandas)</span> 与基础 <span class="highlight">SQL</span>，支持用户分群、流失分析与效果评估。  </li><li><strong>办公软件：</strong> 熟练 Microsoft Office（Excel&#x2F;Word&#x2F;PowerPoint等），能制作数据透视表与可视化报表。  </li><li><strong>行业&#x2F;竞品分析：</strong> 能独立完成行业竞争报告、功能&#x2F;部署&#x2F;价格对比与风险评估。  </li><li><strong>财务报表与分析：</strong> 熟悉资产负债表、利润表、现金流逻辑。  </li><li><strong>Pipeline 管理：</strong> 快速搭建线索 pipeline 与分级表，生成 KPI 仪表盘。  </li><li><strong>语言与沟通：</strong> 中文母语，具备英语工作阅读与口语沟通能力。</li></ul><hr><h2 id="其他能力"><a href="#其他能力" class="headerlink" title="其他能力"></a>其他能力</h2><ul><li><strong>市场洞察力：</strong> 基于行业趋势与用户数据识别商业机会，社媒内容验证能力（累计点赞数<span class="highlight">数十万</span>、<span class="highlight">单个</span>视频播放量<span class="highlight">超 100 万</span>）。  </li><li><strong>人际交往与沟通：</strong> 擅长跨部门协调与客户维护。  </li><li>有良好个人形象和职业素养，能适应出差并具备驾驶能力。</li></ul><hr><p><em>更新时间：2025-09-15</em></p>]]></content>
      
      
      <categories>
          
          <category> Statement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-10. 正则表达式匹配（Regular Expression Matching）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88regular_expression_matching%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88regular_expression_matching%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-06-07</p></blockquote><h1 id="10-正则表达式匹配（Regular-Expression-Matching）"><a href="#10-正则表达式匹配（Regular-Expression-Matching）" class="headerlink" title="10. 正则表达式匹配（Regular Expression Matching）"></a><a href="https://leetcode.cn/problems/regular-expression-matching/"><span style="color:#1E90FF;">10. 正则表达式匹配（Regular Expression Matching）</span></a></h1><h2 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a><span style="color:#228B22;">Hard</span></h2><p>给定输入字符串 <code>s</code> 和模式 <code>p</code>，实现支持 <code>.</code> 与 <code>*</code> 的正则表达式匹配，其中：</p><ul><li><code>.</code> 匹配任意单个字符。</li><li><code>*</code> 匹配零个或多个前面的那一个元素。</li></ul><p>匹配应该覆盖整个输入字符串（不是部分匹配）。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;aa&quot;</code>, <code>p = &quot;a&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>false</code></span></p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;aa&quot;</code>, <code>p = &quot;a*&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>true</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;ab&quot;</code>, <code>p = &quot;.*&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>true</code></span></p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>1 &lt;= s.length &lt;= 20</code>  </li><li><code>1 &lt;= p.length &lt;= 20</code>  </li><li><code>s</code> 仅包含小写英文字母</li><li><code>p</code> 仅包含小写英文字母、<code>.</code> 与 <code>*</code>，且每个 <code>*</code> 前都有合法的字符</li></ul><hr><h2 id="思路概览"><a href="#思路概览" class="headerlink" title="思路概览"></a><span style="color:#8B0000;">思路概览</span></h2><p>此题的核心在于处理 <code>*</code> 带来的“零次或多次”匹配，以及 <code>.</code> 的通配符效果。常见解法有：</p><ul><li><strong>递归（回溯）</strong>：按模式逐步匹配，遇到 <code>*</code> 分支为“使用 0 次”或“使用至少 1 次（并继续匹配）”，直观但会有大量重复计算，可能超时。</li><li><strong>动态规划（DP）</strong>：构造 <code>dp[i][j]</code> 表示 <code>s[0..i)</code> 与 <code>p[0..j)</code> 是否匹配，状态转移要考虑 <code>*</code> 的 0 次或多次两种情况，复杂度可控且常用于通过 OJ。下面给出三种实现（递归与 DP）。</li></ul><hr><h2 id="方法一：递归（带短路的回溯）"><a href="#方法一：递归（带短路的回溯）" class="headerlink" title="方法一：递归（带短路的回溯）"></a><span style="color:#2E8B57;">方法一：递归（带短路的回溯）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p[1] == &#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#x27;*&#x27; 表示 0 次</span></span><br><span class="line">            s = s.<span class="built_in">substr</span>(<span class="number">1</span>); <span class="comment">// &#x27;*&#x27; 表示多次，尝试消费 s 的首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>)); <span class="comment">// &#x27;*&#x27; 表示 0 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>说明：</strong> 实现直观，但对某些输入会重复大量子问题，可能超时。</li></ul><hr><h2 id="方法二：更紧凑的递归（易超时）"><a href="#方法二：更紧凑的递归（易超时）" class="headerlink" title="方法二：更紧凑的递归（易超时）"></a><span style="color:#2E8B57;">方法二：更紧凑的递归（易超时）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>)) || (!s.<span class="built_in">empty</span>() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !s.<span class="built_in">empty</span>() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="方法三：动态规划（推荐）"><a href="#方法三：动态规划（推荐）" class="headerlink" title="方法三：动态规划（推荐）"></a><span style="color:#2E8B57;">方法三：动态规划（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// &#x27;*&#x27; 表示 0 次或多次</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(m * n)  </li><li><strong>空间复杂度：</strong> O(m * n)</li></ul><hr><p><em>作者想说的话：</em><br>处理含 <code>*</code> 的正则匹配要么用回溯分支枚举（直观但易重复），要么用 DP 消除重叠子问题。掌握 DP 的状态转移是通过此题的关键。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-9. 回文数（Palindrome Number）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-9-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88palindrome_number%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-9-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88palindrome_number%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-06-04</p></blockquote><h1 id="9-回文数（Palindrome-Number）"><a href="#9-回文数（Palindrome-Number）" class="headerlink" title="9. 回文数（Palindrome Number）"></a><a href="https://leetcode.cn/problems/palindrome-number/"><span style="color:#1E90FF;">9. 回文数（Palindrome Number）</span></a></h1><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a><span style="color:#228B22;">Easy</span></h2><p>给定一个整数 <code>x</code>，若 <code>x</code> 是回文整数则返回 <code>true</code>，否则返回 <code>false</code>。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x = 121</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>true</code></span><br><strong>解释：</strong> 从左到右和从右到左都是 <code>121</code>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x = -121</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>false</code></span><br><strong>解释：</strong> 从左到右为 <code>-121</code>，从右到左为 <code>121-</code>，因此不是回文。</p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x = 10</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>false</code></span><br><strong>解释：</strong> 反向为 <code>01</code>，因此不是回文。</p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>-2^&#123;31&#125; &lt;= x &lt;= 2^&#123;31&#125; - 1</code></li></ul><p><strong>进阶：</strong> 你能在不将整数转换为字符串的情况下解决此题吗？</p><hr><h2 id="思路与常见解法"><a href="#思路与常见解法" class="headerlink" title="思路与常见解法"></a><span style="color:#8B0000;">思路与常见解法</span></h2><p>把整数转换为字符串后判断回文是最直接的方法，但进阶要求不允许字符串转换，可以用以下数学方法：</p><ol><li><p><strong>首尾位比较（取整&#x2F;取余法）</strong>：通过计算除数 <code>div</code>（使 <code>x/div</code> 得到最高位），比较最高位与最低位（<code>x%10</code>），然后去掉首尾继续比较。需要注意更新 <code>div</code>（每次去除两位后 <code>div</code> 除以 100）。</p></li><li><p><strong>翻转后半段（反转半段法）</strong>：将数字的后半段反转，直到反转后的数 <code>revertNum</code> &gt;&#x3D; 剩余的 <code>x</code> 为止；若为回文则两者相等（偶数位）或 <code>revertNum/10 == x</code>（奇数位）。此方法无需处理溢出（若溢出则不是回文）。</p></li><li><p><strong>直接调用反转并比较（借助 Reverse Integer）</strong>：若反转后的值与原值相等则为回文，但需注意反转可能溢出，若溢出则直接返回 false。</p></li></ol><p>下面给出三种实现。</p><hr><h2 id="方法一：首尾位比较（取整-取余）"><a href="#方法一：首尾位比较（取整-取余）" class="headerlink" title="方法一：首尾位比较（取整&#x2F;取余）"></a><span style="color:#2E8B57;">方法一：首尾位比较（取整&#x2F;取余）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = x / div;</span><br><span class="line">            <span class="type">int</span> right = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = (x % div) / <span class="number">10</span>; <span class="comment">// 去掉首尾两位</span></span><br><span class="line">            div /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log10(x))（位数相关）  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法二：翻转后半段（反转半段法）"><a href="#方法二：翻转后半段（反转半段法）" class="headerlink" title="方法二：翻转后半段（反转半段法）"></a><span style="color:#2E8B57;">方法二：翻转后半段（反转半段法）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> revertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertNum) &#123;</span><br><span class="line">            revertNum = revertNum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == revertNum || x == revertNum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log10(x))  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法三：反转并比较（复用-Reverse-Integer）"><a href="#方法三：反转并比较（复用-Reverse-Integer）" class="headerlink" title="方法三：反转并比较（复用 Reverse Integer）"></a><span style="color:#2E8B57;">方法三：反转并比较（复用 Reverse Integer）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>说明：</strong> 若反转过程中发生溢出，则返回 -1，表示不是回文。</li></ul><hr><p><em>作者想说的话：</em><br>不使用字符串时，可以通过取整&#x2F;取余或反转后半段两种数学方式判断回文，二者时间复杂度均与数字位数成正比，且空间复杂度为常数。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 取整取余 </tag>
            
            <tag> 反转半段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-8. 字符串转整数（String to Integer atoi）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88string_to_integer_atoi%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88string_to_integer_atoi%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-06-01</p></blockquote><h1 id="8-字符串转整数（String-to-Integer-atoi）"><a href="#8-字符串转整数（String-to-Integer-atoi）" class="headerlink" title="8. 字符串转整数（String to Integer, atoi）"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/"><span style="color:#1E90FF;">8. 字符串转整数（String to Integer, atoi）</span></a></h1><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a><span style="color:#228B22;">Medium</span></h2><p>实现 <code>myAtoi(string s)</code> 函数，将字符串转换为 32 位带符号整数（类似 C&#x2F;C++ 的 <code>atoi</code>）。算法规则如下：</p><ol><li>读取并忽略开头的空白字符。</li><li>检查下一个字符是否为 <code>-</code> 或 <code>+</code>，若是则记录符号并读取该字符；否则默认正数。</li><li>继续读取后续的数字字符直到遇到非数字或字符串末尾，其他字符均忽略。</li><li>将读取的数字字符转换为整数（例如 “0032” -&gt; 32）；若没有读取到任何数字，则返回 0。根据步骤 2 中的符号调整正负。</li><li>若转换后的整数超出 32 位带符号整数范围 <code>[-2^31, 2^31 - 1]</code>，则截断为边界值。</li><li>返回最终结果。</li></ol><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;42&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>42</code></span></p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;   -42&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>-42</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;4193 with words&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>4193</code></span></p><h3 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><span style="color:#800080;">示例 4：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;words and 987&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>0</code></span></p><h3 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><span style="color:#800080;">示例 5：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;-91283472332&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>-2147483648</code></span></p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>0 &lt;= s.length &lt;= 200</code>  </li><li><code>s</code> 由大小写英文字母、数字、空格、<code>+</code>、<code>-</code>、<code>.</code> 组成</li></ul><hr><h2 id="解题思路（要点）"><a href="#解题思路（要点）" class="headerlink" title="解题思路（要点）"></a><span style="color:#8B0000;">解题思路（要点）</span></h2><p>此题本质是对字符串进行逐字符解析并做边界处理，关键点：</p><ul><li>按照指定顺序处理：跳过前导空格 -&gt; 读取可选符号 -&gt; 连续读取数字字符。</li><li>在逐位构造整数时必须做溢出检测，避免超出 32 位范围；常见做法是在将 <code>base</code> 乘 10 并加上新数位之前判断 <code>base &gt; INT_MAX/10</code> 或 <code>base == INT_MAX/10 &amp;&amp; digit &gt; 7</code>（针对正数）等情况并直接返回边界值。</li><li>只处理前导空格和首段连续数字，遇到其他非数字字符即停止解析。</li></ul><p>实现上可直接按流程写模拟解析（指针推进、条件判断），也可用有限状态机（状态：起始、符号、数字、结束）来严格控制输入流的处理。</p><hr><h2 id="C-实现（直接模拟）"><a href="#C-实现（直接模拟）" class="headerlink" title="C++ 实现（直接模拟）"></a><span style="color:#2E8B57;">C++ 实现（直接模拟）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>, base = <span class="number">0</span>, i = <span class="number">0</span>, n = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 跳过前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) ++i;</span><br><span class="line">        <span class="comment">// 读取符号</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            sign = (str[i++] == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取数字并转换</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> digit = str[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 溢出检测</span></span><br><span class="line">            <span class="keyword">if</span> (base &gt; INT_MAX / <span class="number">10</span> || (base == INT_MAX / <span class="number">10</span> &amp;&amp; digit &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (sign == <span class="number">1</span>) ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            base = base * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)（一次线性扫描）  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><p><em>作者想说的话：</em><br>字符串转整数主要考验对输入流的严格解析能力与边界判断：先按步骤跳过空白、读取符号、逐位累加数字并实时做溢出检测。使用有限状态机可以让实现更规范、更易验证，但对该题直接流程化实现也很清晰。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 状态机 </tag>
            
            <tag> 溢出检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-7. 整数反转（Reverse Integer）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88reverse_integer%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88reverse_integer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-05-29</p></blockquote><h1 id="7-整数反转（Reverse-Integer）"><a href="#7-整数反转（Reverse-Integer）" class="headerlink" title="7. 整数反转（Reverse Integer）"></a><a href="https://leetcode.cn/problems/reverse-integer/"><span style="color:#1E90FF;">7. 整数反转（Reverse Integer）</span></a></h1><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a><span style="color:#228B22;">Easy</span></h2><p>给定一个带符号的 32 位整数 <code>x</code>，将 <code>x</code> 的数字部分反转后返回。如果反转后整数溢出（超出有符号 32 位整数范围 <code>[-2^31, 2^31-1]</code>），则返回 <code>0</code>。</p><blockquote><p>假设运行环境不允许使用 64 位整型（signed 或 unsigned）。</p></blockquote><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x =  123</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>321</code></span></p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x = -123</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>-321</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>x = 120</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>21</code></span></p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>-2^&#123;31&#125; &lt;= x &lt;= 2^&#123;31&#125; - 1</code></li></ul><hr><h2 id="题目要点与溢出处理"><a href="#题目要点与溢出处理" class="headerlink" title="题目要点与溢出处理"></a><span style="color:#8B0000;">题目要点与溢出处理</span></h2><p>反转整数的关键在于逐位取出数字并按位构造反转后的结果，同时要在每一步检测是否会造成溢出。因为题目限定不能使用 64 位整型（在某些 OJ 环境下），所以需要用 <code>int</code> 并在乘 10 或加下一位之前判断是否会越界。</p><p>一种常见且优雅的判定方法是：在将 <code>res</code> 乘以 10 之前检查 <code>abs(res) &gt; INT_MAX / 10</code>（若为真则一定会溢出），这样可以在溢出发生前返回 0。该方法无需专门处理正负号，因为 <code>%</code> 操作在 C++ 中对负数依然返回负的余数，<code>/</code> 对负数也按向零截断，按位操作自然成立。</p><hr><h2 id="解法一：不使用-long，逐位检测溢出（推荐）"><a href="#解法一：不使用-long，逐位检测溢出（推荐）" class="headerlink" title="解法一：不使用 long，逐位检测溢出（推荐）"></a><span style="color:#2E8B57;">解法一：不使用 long，逐位检测溢出（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(res) &gt; INT_MAX / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 溢出检测</span></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log|x|)（与位数成比例）  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><p><strong>说明：</strong> 在每次乘 10 之前判断 <code>abs(res) &gt; INT_MAX/10</code> 即可保证后续不会溢出。</p><hr><h2 id="解法二：使用-long-做中间值（思路拓展）"><a href="#解法二：使用-long-做中间值（思路拓展）" class="headerlink" title="解法二：使用 long 做中间值（思路拓展）"></a><span style="color:#2E8B57;">解法二：使用 long 做中间值（思路拓展）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="number">10</span> * res + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res &gt; INT_MAX || res &lt; INT_MIN) ? <span class="number">0</span> : (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log|x|)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><p><strong>备注：</strong> 虽然该方法实现简单，但题目要求假设环境不允许使用 64 位整数，因此此方法仅作为思路补充。</p><hr><h2 id="关于是否需要等于-INT-MAX-10-的额外判断"><a href="#关于是否需要等于-INT-MAX-10-的额外判断" class="headerlink" title="关于是否需要等于 INT_MAX/10 的额外判断"></a><span style="color:#2E8B57;">关于是否需要等于 <code>INT_MAX/10</code> 的额外判断</span></h2><p>有些讨论会问：是否还需要在 <code>res == INT_MAX/10</code> 时进一步判断下一位（比如 <code>x%10 &gt; 7</code>）来决定是否溢出？对于本题的整数范围和按位处理流程，使用 <code>abs(res) &gt; INT_MAX/10</code> 的判断已足够，因为输入 <code>x</code> 本身也是 <code>int</code>，不可能提供使得 <code>res</code> 在等于 <code>INT_MAX/10</code> 时再进一步产生非法情形的越界下一位（详见常见证明）。若采用不使用 <code>abs</code> 的写法，可额外检查 <code>res == INT_MAX/10 &amp;&amp; x%10 &gt; 7</code> 或 <code>res == INT_MIN/10 &amp;&amp; x%10 &lt; -8</code>。</p><hr><p><em>作者想说的话：</em><br>整数翻转题主要考察对位运算&#x2F;取余、边界与溢出的敏感性。解题思路是逐位提取数字并在每一步进行溢出检测：推荐在乘以 10 或加下一位之前检查是否会越界（例如 abs(res) &gt; INT_MAX&#x2F;10），若环境允许也可用 64 位整型作为中间值简化实现。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 溢出检测 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-6. Z字变换（ZigZag Conversion）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-6-z%E5%AD%97%E5%8F%98%E6%8D%A2%EF%BC%88zig_zag_conversion%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-6-z%E5%AD%97%E5%8F%98%E6%8D%A2%EF%BC%88zig_zag_conversion%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-26</p></blockquote><h1 id="6-Z字变换（ZigZag-Conversion）"><a href="#6-Z字变换（ZigZag-Conversion）" class="headerlink" title="6. Z字变换（ZigZag Conversion）"></a><a href="https://leetcode.cn/problems/zigzag-conversion/"><span style="color:#1E90FF;">6. Z字变换（ZigZag Conversion）</span></a></h1><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a><span style="color:#228B22;">Medium</span></h2><p>将字符串 <code>s</code> 按给定行数 <code>numRows</code> 以之字形排列，然后逐行读取得到新的字符串并返回。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;PAYPALISHIRING&quot;</code>, <code>numRows = 3</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>&quot;PAHNAPLSIIGYIR&quot;</code></span></p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;PAYPALISHIRING&quot;</code>, <code>numRows = 4</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>&quot;PINALSIGYAHRPI&quot;</code></span><br><strong>解释：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;A&quot;</code>, <code>numRows = 1</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>&quot;A&quot;</code></span></p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>1 &lt;= s.length &lt;= 1000</code>  </li><li><code>s</code> 由大小写英文字母、<code>,</code> 和 <code>.</code> 组成  </li><li><code>1 &lt;= numRows &lt;= 1000</code></li></ul><hr><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><span style="color:#8B0000;">问题分析</span></h2><p>将字符串按 <code>numRows</code> 行以之字形排列，观察各行字符在原串中的下标规律可以发现：</p><ul><li>当 <code>numRows == 1</code> 时，原串即为结果。</li><li>用 <code>cycle = 2 * numRows - 2</code> 表示一个完整纵向+斜向的周期（首尾行没有斜向元素）。</li><li>对于首行和尾行，相邻两个字符在原串中的下标差为 <code>cycle</code>。</li><li>对于中间行（i 行，0 &lt; i &lt; numRows-1），每个周期会出现两个字符：一个在 <code>j</code>（基于首个周期偏移）的黑色位置，另一个在 <code>j + cycle - 2*i</code> 的红色位置（若该位置存在）。</li></ul><p>根据上述规律可以有两类解法：按数学规律直接计算下标（一次拼接即可），或模拟之字形把字符填到每一行的字符串数组，最后合并各行。</p><hr><h2 id="方法一：按下标规律直接拼接（一次遍历每一行）"><a href="#方法一：按下标规律直接拼接（一次遍历每一行）" class="headerlink" title="方法一：按下标规律直接拼接（一次遍历每一行）"></a><span style="color:#2E8B57;">方法一：按下标规律直接拼接（一次遍历每一行）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> cycle = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j += cycle) &#123;</span><br><span class="line">                res += s[j];</span><br><span class="line">                <span class="type">int</span> pos = j + cycle - <span class="number">2</span> * i; <span class="comment">// 中间斜向元素的位置</span></span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; pos &lt; n) res += s[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(1)（不含返回字符串）</li></ul><p><strong>要点：</strong> 直接按行计算字符在原串中的下标，不做额外模拟，速度快且代码简洁。</p><hr><h2 id="方法二：模拟之字形（更直观）"><a href="#方法二：模拟之字形（更直观）" class="headerlink" title="方法二：模拟之字形（更直观）"></a><span style="color:#2E8B57;">方法二：模拟之字形（更直观）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(min(numRows, n))</span></span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// 当前行</span></span><br><span class="line">        <span class="type">bool</span> goingDown = <span class="literal">false</span>; <span class="comment">// 方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            rows[cur] += c;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span> || cur == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">            cur += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : rows) res += row;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(n)</li></ul><p><strong>要点：</strong> 使用 <code>numRows</code> 个字符串来模拟每一行的字符，按“竖 + 斜”方向切换填充，最后拼接即可，代码直观易懂。</p><hr><h2 id="复杂度与选择建议"><a href="#复杂度与选择建议" class="headerlink" title="复杂度与选择建议"></a><span style="color:#2E8B57;">复杂度与选择建议</span></h2><ul><li>两种方法时间复杂度同为 O(n)，但方法一更节省额外空间且常数项更小；方法二更直观，易于实现和理解。</li><li>当 <code>numRows</code> 很大接近 <code>s.length()</code> 时，方法二仍然稳定；当追求极致性能时推荐方法一。</li></ul><hr><p><em>作者想说的话：</em><br>Z 字变换题主要考察对下标规律的观察与字符串拼接能力。先写模拟法通过样例，再补充按下标的 O(1) 空间解法会更稳妥。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-5. 最长回文子串（Longest Palindromic Substring）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88longest_palindromic_substring%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88longest_palindromic_substring%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-23</p></blockquote><h1 id="5-最长回文子串（Longest-Palindromic-Substring）"><a href="#5-最长回文子串（Longest-Palindromic-Substring）" class="headerlink" title="5. 最长回文子串（Longest Palindromic Substring）"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/"><span style="color:#1E90FF;">5. 最长回文子串（Longest Palindromic Substring）</span></a></h1><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a><span style="color:#228B22;">Medium</span></h2><p>给定一个字符串 <code>s</code>，返回 <code>s</code> 中<strong>最长的回文子串</strong>。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;babad&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>&quot;bab&quot;</code></span><br><strong>解释：</strong> <code>&quot;aba&quot;</code> 也是可接受的答案。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>s = &quot;cbbd&quot;</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>&quot;bb&quot;</code></span></p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>1 &lt;= s.length &lt;= 1000</code>  </li><li><code>s</code> 仅由数字和英文字母组成</li></ul><hr><h2 id="问题分析与常用解法概览"><a href="#问题分析与常用解法概览" class="headerlink" title="问题分析与常用解法概览"></a><span style="color:#8B0000;">问题分析与常用解法概览</span></h2><p>回文串是正读反读都相同的字符串，如 <code>&quot;bob&quot;</code>、<code>&quot;level&quot;</code>、<code>&quot;noon&quot;</code> 等。求最长回文子串的常见方法包括：</p><ol><li>中心扩展（Expand Around Center）——时间复杂度 O(n^2)，实现简单且常用。需同时处理奇偶长度回文。推荐在面试中先写这个并通过边界测试。</li><li>改进中心扩展的快速跳过重复字符方法——在遇到连续相同字符时先跳过以合并奇偶情形，能减少常数项操作。</li><li>动态规划（DP）——维护 <code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文，时间与空间均为 O(n^2)，思路直观但空间开销大。</li><li>马拉车（Manacher）算法——将时间复杂度降到 O(n)，算法较巧妙但写起来相对复杂，适合追求最优时间的场景或刷题进阶。</li></ol><p>下面给出四种实现（C++），并分别说明复杂度与要点。</p><hr><h2 id="方法一：中心扩展（基础版）"><a href="#方法一：中心扩展（基础版）" class="headerlink" title="方法一：中心扩展（基础版）"></a><span style="color:#2E8B57;">方法一：中心扩展（基础版）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 偶数回文（中心在 i 和 i+1 之间）</span></span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i<span class="number">+1</span>, start, maxLen);</span><br><span class="line">            <span class="comment">// 奇数回文（中心在 i）</span></span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i, start, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>&amp; start, <span class="type">int</span>&amp; maxLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left; ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">            maxLen = len;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n^2)（最坏情况下每个中心扩展 O(n)）  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法二：中心扩展-跳过重复字符（优化常数项）"><a href="#方法二：中心扩展-跳过重复字符（优化常数项）" class="headerlink" title="方法二：中心扩展 + 跳过重复字符（优化常数项）"></a><span style="color:#2E8B57;">方法二：中心扩展 + 跳过重复字符（优化常数项）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n - i &lt;= maxLen / <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// 剩余长度不足以改写 maxLen</span></span><br><span class="line">            <span class="type">int</span> left = i, right = i;</span><br><span class="line">            <span class="comment">// 跳过右侧的重复字符（合并偶数中心）</span></span><br><span class="line">            <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; s[right + <span class="number">1</span>] == s[right]) ++right;</span><br><span class="line">            i = right + <span class="number">1</span>; <span class="comment">// 下一个中心从跳过重复字符后开始</span></span><br><span class="line">            <span class="comment">// 向两侧扩展</span></span><br><span class="line">            <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; right + <span class="number">1</span> &lt; n &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                --left; ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                maxLen = right - left + <span class="number">1</span>;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> 仍为 O(n^2) 最坏，但常数项更小，实际更快。  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法三：动态规划（DP）"><a href="#方法三：动态规划（DP）" class="headerlink" title="方法三：动态规划（DP）"></a><span style="color:#2E8B57;">方法三：动态规划（DP）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[j][i] = (s[i] == s[j]) &amp;&amp; (i - j &lt; <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (dp[j][i] &amp;&amp; i - j + <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">                    len = i - j + <span class="number">1</span>;</span><br><span class="line">                    left = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n^2)  </li><li><strong>空间复杂度：</strong> O(n^2)</li></ul><p><strong>备注：</strong> DP 直观但内存占用大，适合想要用状态定义来证明正确性的场景。</p><hr><h2 id="方法四：马拉车（Manacher）算法（O-n-）"><a href="#方法四：马拉车（Manacher）算法（O-n-）" class="headerlink" title="方法四：马拉车（Manacher）算法（O(n)）"></a><span style="color:#8B0000;">方法四：马拉车（Manacher）算法（O(n)）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 将字符串转换为带分隔符的形式，方便统一处理奇偶回文</span></span><br><span class="line">        string t = <span class="string">&quot;^#&quot;</span>; <span class="comment">// ^ 作为起始哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123; t += c; t += <span class="string">&#x27;#&#x27;</span>; &#125;</span><br><span class="line">        t += <span class="string">&#x27;$&#x27;</span>; <span class="comment">// $ 作为结尾哨兵</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> center = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 当前回文中心及其右边界</span></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>, centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> mirror = <span class="number">2</span> * center - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; right) p[i] = <span class="built_in">min</span>(right - i, p[mirror]);</span><br><span class="line">            <span class="keyword">else</span> p[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 中心扩展</span></span><br><span class="line">            <span class="keyword">while</span> (t[i + <span class="number">1</span> + p[i]] == t[i - <span class="number">1</span> - p[i]]) ++p[i];</span><br><span class="line">            <span class="comment">// 更新中心和右边界</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                centerIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">// 映射回原字符串的起始位置</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(n)（用于转换后的字符串与半径数组）</li></ul><p><strong>要点：</strong> Manacher 在预处理后把奇偶回文统一成奇数情形，使用已知回文信息来跳过重复扩展，显著减少重复比较。</p><hr><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a><span style="color:#2E8B57;">总结与建议</span></h2><ul><li>面试中优先写<strong>中心扩展</strong>解法（方法一或方法二），清晰易懂且能通过大多数测试；若需要更优的时间复杂度或想展示更高算法能力，再写 Manacher（方法四）。</li><li>动态规划适合证明和练手，但实现占用内存较大。</li><li>建议手写并调试中心扩展与 Manacher，熟悉两者的边界处理技巧（空串、全相同字符、偶数&#x2F;奇数回文等）。</li></ul><hr><p><em>作者想说的话：</em><br>最长回文子串是字符串类题目的经典题型，理解“以中心扩展”与“预处理统一奇偶”的思想，会为你解其他字符串分割&#x2F;匹配问题打下良好基础。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-4. 寻找两个正序数组的中位数（Median of Two Sorted Arrays）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88Median%20of%20Two%20Sorted%20Arrays%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88Median%20of%20Two%20Sorted%20Arrays%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-05-20</p></blockquote><h1 id="4-寻找两个正序数组的中位数（Median-of-Two-Sorted-Arrays）"><a href="#4-寻找两个正序数组的中位数（Median-of-Two-Sorted-Arrays）" class="headerlink" title="4. 寻找两个正序数组的中位数（Median of Two Sorted Arrays）"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><span style="color:#1E90FF;">4. 寻找两个正序数组的中位数（Median of Two Sorted Arrays）</span></a></h1><h2 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a><span style="color:#228B22;">Hard</span></h2><p>给定两个 <strong>有序</strong> 数组 <code>nums1</code> 和 <code>nums2</code>，大小分别为 <code>m</code> 和 <code>n</code>，请你找出这两个正序数组的中位数，并且要求总体运行时间复杂度为 <strong>O(log(m + n))</strong>。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>nums1 = [1,3]</code>, <code>nums2 = [2]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>2.00000</code></span><br><strong>解释：</strong> 合并后数组为 <code>[1,2,3]</code>，中位数是 <code>2</code>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>nums1 = [1,2]</code>, <code>nums2 = [3,4]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>2.50000</code></span><br><strong>解释：</strong> 合并后数组为 <code>[1,2,3,4]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code>。</p><hr><h3 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><span style="color:#FF8C00;">约束：</span></h3><ul><li><code>nums1.length == m</code>  </li><li><code>nums2.length == n</code>  </li><li><code>0 &lt;= m &lt;= 1000</code>  </li><li><code>0 &lt;= n &lt;= 1000</code>  </li><li><code>1 &lt;= m + n &lt;= 2000</code>  </li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><hr><h2 id="问题分析（关键思路）"><a href="#问题分析（关键思路）" class="headerlink" title="问题分析（关键思路）"></a><span style="color:#8B0000;">问题分析（关键思路）</span></h2><p>题目要求时间复杂度为 <code>O(log(m+n))</code>，因此自然想到二分查找。但难点在于：如何在两个<strong>未合并</strong>的有序数组之间应用二分法？常见且直观的解决思路有三种：</p><ol><li><p><strong>二分查找「第 K 小」元素</strong>（把求中位数转成查第 k 小的问题）：  </p><ul><li>设总长度为 <code>m + n</code>，中位数可统一用 <code>(findKth((m+n+1)/2) + findKth((m+n+2)/2)) / 2.0</code> 处理奇偶两种情况。  </li><li>关键是实现 <code>findKth(nums1, i, nums2, j, k)</code>：每次比较两个数组的第 <code>k/2</code> 个元素，较小的一方前 <code>k/2</code> 个元素可以被淘汰（因为它们不可能是第 k 小），然后递归&#x2F;迭代继续在剩余元素里查找第 <code>k - k/2</code> 小。时间复杂度 <code>O(log(m+n))</code>（严格讲为 <code>O(log(m+n))</code> 的因子取决于每次 k 减少比例），空间复杂度取决于递归深度或使用迭代 <code>O(1)</code>。</li></ul></li><li><p><strong>变体：拷贝法（不推荐，用于思路拓展）</strong>：  </p><ul><li>每次通过切片构造新的子数组（复制数据），同样按 <code>k/2</code> 淘汰，但会发生数组拷贝，实际时间&#x2F;空间成本较高，不建议在面试&#x2F;工程中使用，只作思路补充。</li></ul></li><li><p><strong>迭代二分切分法（推荐）</strong>：  </p><ul><li>将两个数组“切分”为左右两部分，要求左侧元素个数等于右侧元素个数（或相差 1），并且满足 <code>max(left parts) &lt;= min(right parts)</code>，则中位数为：<code>(max(L1,L2) + min(R1,R2)) / 2</code>。  </li><li>对切分点在短数组上二分，时间复杂度 <code>O(log(min(m, n)))</code>，这是最常见且优雅的解法（也能很好的在面试中阐述）。</li></ul></li></ol><p>下面给出三种 C++ 实现（对应上面三类思路），并说明复杂度。</p><hr><h2 id="方法一：二分查找第-K-小（递归实现）"><a href="#方法一：二分查找第-K-小（递归实现）" class="headerlink" title="方法一：二分查找第 K 小（递归实现）"></a><span style="color:#2E8B57;">方法一：二分查找第 K 小（递归实现）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> right = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + <span class="built_in">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> i, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= (<span class="type">int</span>)nums<span class="number">1.</span><span class="built_in">size</span>()) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= (<span class="type">int</span>)nums<span class="number">2.</span><span class="built_in">size</span>()) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> midVal1 = (i + k/<span class="number">2</span> - <span class="number">1</span> &lt; (<span class="type">int</span>)nums<span class="number">1.</span><span class="built_in">size</span>()) ? nums1[i + k/<span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        <span class="type">int</span> midVal2 = (j + k/<span class="number">2</span> - <span class="number">1</span> &lt; (<span class="type">int</span>)nums<span class="number">2.</span><span class="built_in">size</span>()) ? nums2[j + k/<span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal1 &lt; midVal2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1, i + k/<span class="number">2</span>, nums2, j, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1, i, nums2, j + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log(m + n))（每次 k 约减半）  </li><li><strong>空间复杂度：</strong> 递归栈 O(log(m + n))（可改为迭代降低栈深）</li></ul><p><strong>思路要点：</strong> 同时在两个数组上「按 k&#x2F;2 划分」，较小一侧可以一次性淘汰 k&#x2F;2 个元素，继续在剩余元素中查找第 <code>k - k/2</code> 小。</p><hr><h2 id="方法二：拷贝子数组的递归（思路拓展，不推荐）"><a href="#方法二：拷贝子数组的递归（思路拓展，不推荐）" class="headerlink" title="方法二：拷贝子数组的递归（思路拓展，不推荐）"></a><span style="color:#2E8B57;">方法二：拷贝子数组的递归（思路拓展，不推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">findKth</span>(nums1, nums2, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + <span class="built_in">findKth</span>(nums1, nums2, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums1, vector&lt;<span class="type">int</span>&gt; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums<span class="number">1.</span><span class="built_in">empty</span>()) <span class="keyword">return</span> nums2[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums<span class="number">2.</span><span class="built_in">empty</span>()) <span class="keyword">return</span> nums1[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">min</span>((<span class="type">int</span>)nums<span class="number">1.</span><span class="built_in">size</span>(), k / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">min</span>((<span class="type">int</span>)nums<span class="number">2.</span><span class="built_in">size</span>(), k / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 丢弃 nums2 的前 j 个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">begin</span>() + j, nums<span class="number">2.</span><span class="built_in">end</span>()), k - j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 丢弃 nums1 的前 i 个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKth</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">1.</span><span class="built_in">begin</span>() + i, nums<span class="number">1.</span><span class="built_in">end</span>()), nums2, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> 理论上与方法一类似，但因为每次 <code>vector</code> 切片会发生拷贝，实际开销高。  </li><li><strong>空间复杂度：</strong> 较高（频繁分配&#x2F;复制）。</li></ul><p><strong>备注：</strong> 此法更直观但不高效，多用于理解或稿子中的思路演示。</p><hr><h2 id="方法三：迭代二分切分法（推荐）"><a href="#方法三：迭代二分切分法（推荐）" class="headerlink" title="方法三：迭代二分切分法（推荐）"></a><span style="color:#8B0000;">方法三：迭代二分切分法（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 保证 nums2 是较短的数组（在较短数组上二分）</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// nums2 为空，直接返回 nums1 的中位数</span></span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">double</span>)nums1[(m - <span class="number">1</span>) / <span class="number">2</span>] + (<span class="type">double</span>)nums1[m / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n * <span class="number">2</span>; <span class="comment">// 使用“插入#后的坐标系”，长度乘2处理奇偶统一</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid2 = (left + right) / <span class="number">2</span>;     <span class="comment">// 在短数组 nums2 上的切分点（*2 坐标系）</span></span><br><span class="line">            <span class="type">int</span> mid1 = m + n - mid2;          <span class="comment">// 在 nums1 上的切分点（由总长度决定）</span></span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> L1 = (mid1 == <span class="number">0</span>) ? INT_MIN : nums1[(mid1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> L2 = (mid2 == <span class="number">0</span>) ? INT_MIN : nums2[(mid2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> R1 = (mid1 == m * <span class="number">2</span>) ? INT_MAX : nums1[mid1 / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> R2 = (mid2 == n * <span class="number">2</span>) ? INT_MAX : nums2[mid2 / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (L1 &gt; R2) left = mid2 + <span class="number">1</span>;    <span class="comment">// nums1 左边太大，需要把 nums2 的切分点右移（增大 mid2）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1) right = mid2 - <span class="number">1</span>; <span class="comment">// nums2 左边太大，需要把 nums2 的切分点左移</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到合适切分</span></span><br><span class="line">                <span class="built_in">return</span> (<span class="built_in">max</span>(L1, L2) + <span class="built_in">min</span>(R1, R2)) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不应到达</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(log(min(m, n))) —— 在较短的数组上二分。  </li><li><strong>空间复杂度：</strong> O(1)。</li></ul><p><strong>关键点：</strong></p><ul><li>把两个数组各自切分为左右两部分，保证左边元素总数等于右边元素总数（或相差 1），并且满足 <code>L1 &lt;= R2 &amp;&amp; L2 &lt;= R1</code>。  </li><li>处理边界时把不存在的位置用 <code>INT_MIN</code> &#x2F; <code>INT_MAX</code> 填充，代码更简洁。  </li><li>为了使二分在短数组上进行，先交换数组确保 <code>nums2</code> 是较短的。</li></ul><hr><h2 id="复杂度与实现要点总结"><a href="#复杂度与实现要点总结" class="headerlink" title="复杂度与实现要点总结"></a><span style="color:#2E8B57;">复杂度与实现要点总结</span></h2><ul><li>二分第 K 小（方法一）与迭代切分（方法三）都能满足题目 <code>O(log(m+n))</code> 的要求，方法三在常见实现中更为优雅且常被面试官接受（时间复杂度 <code>O(log(min(m,n)))</code>）。</li><li>注意处理边界（数组为空、切分到末端等）时使用极值占位可以简化判断。</li><li>拷贝子数组的方法（方法二）思想清晰但会带来额外拷贝成本，不推荐在面试或性能敏感场景使用。</li></ul><hr><p><em>作者想说的话：</em><br>这道题的要点不在于繁琐的实现，而在于能把“中位数”问题转化为「第 k 小」或「两个数组的切分点」问题，然后用二分把问题规模迅速缩小。掌握这些思路后，面对其他需要在两个有序结构上做对齐或分割的问题也会胸有成竹。推荐练习变体题目并手写几次边界情况以加深理解。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-3-无重复字符的最长子串（Longest Substring Without Repeating Characters）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-20</p></blockquote><h1 id="3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）"><a href="#3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）" class="headerlink" title="3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/"><span style="color:#1E90FF;">3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color:#FFA500;">中等</span></h2><p>给定一个字符串 s，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “abcabcbb”</span><br><strong>输出：</strong> <span style="color:#FF4500;">3</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “bbbbb”</span><br><strong>输出：</strong> <span style="color:#FF4500;">1</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “pwwkew”</span><br><strong>输出：</strong> <span style="color:#FF4500;">3</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3，注意答案必须是子串长度。</p><hr><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h2><ul><li><span style="color:#2E8B57;">0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4</span>  </li><li><span style="color:#2E8B57;">s 由英文字母、数字、符号和空格组成</span></li></ul><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><p><strong>思路：</strong><br>从字符串的每一个起始位置出发，依次向后扩展子串，同时使用一个布尔数组或集合来记录当前子串中出现过的字符，一旦遇到重复字符，则停止扩展，对比记录最长长度。该方法直观易懂，但效率较低。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">seen</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]]) <span class="keyword">break</span>;</span><br><span class="line">                seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]] = <span class="literal">true</span>;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n^3)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a><span style="color:#8B0000;">方法二：滑动窗口</span></h2><p><strong>思路：</strong><br>维护一个滑动窗口，用两个指针 l(图中为j)（左边界）和 r(图中为i)（右边界），以及一个哈希数组记录窗口内字符出现次数。当右指针包含的新字符导致重复时，就移动左指针并更新计数，直到窗口中不再有重复字符，同时每次都更新最大窗口长度。</p><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747735661/7f31718c-ff49-42be-a285-5dc8980f57af.png" alt="图1"><br><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747735793/9f054294-e6a4-471d-9e5e-f20f0da07ffb.png" alt="图2"></p><ul><li>以上两图来自力扣题解</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            ++count[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (count[s[r]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --count[s[l]];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法三：优化滑动窗口（记录上次出现位置）"><a href="#方法三：优化滑动窗口（记录上次出现位置）" class="headerlink" title="方法三：优化滑动窗口（记录上次出现位置）"></a><span style="color:#8B0000;">方法三：优化滑动窗口（记录上次出现位置）</span></h2><p><strong>思路：</strong><br>使用数组 lastSeen 记录每个字符上次出现的索引，当遍历到字符 s[i] 时，若 lastSeen[s[i]] 在当前窗口内，则直接将左边界 start 移动到 lastSeen[s[i]] + 1，这样无需逐步移动指针，窗口始终保持无重复状态，同时更新最长长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastSeen</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            start = <span class="built_in">max</span>(start, lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] + <span class="number">1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">            lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="算法性能与系统原理"><a href="#算法性能与系统原理" class="headerlink" title="算法性能与系统原理"></a>算法性能与系统原理</h2><p>在实际工程中，算法的运行速度与空间占用不仅取决于<strong>算法复杂度</strong>，还深受<strong>底层系统架构</strong>、<strong>缓存局部性</strong>和<strong>内存分配策略</strong>的影响。</p><ol><li><p><strong>缓存命中率（Cache Locality）：</strong>  </p><ul><li><strong>方法一</strong>每次内层循环都重置布尔数组，随机访问计数，导致CPU缓存难以复用，缓存未命中率高，实际运行速度远低于理论复杂度。  </li><li><strong>方法二</strong>与<strong>方法三</strong>使用连续数组存储字符计数或上次出现位置，读取和写入集中在数组局部，具有良好的缓存局部性，缓存命中率高，实际性能优越。</li></ul></li><li><p><strong>分支预测与流水线：</strong>  </p><ul><li><code>while (count[s[r]] &gt; 1)</code>等条件分支会影响CPU流水线。<strong>方法二</strong>中的循环分支较多，而<strong>方法三</strong>通过直接计算新边界减少了条件判断次数，分支更容易预测，流水线停顿更少。</li></ul></li><li><p><strong>内存占用和频繁分配：</strong>  </p><ul><li><strong>方法一</strong>每次迭代都开辟新 <code>vector&lt;bool&gt;</code> 或集合，触发频繁内存分配和释放；  </li><li><strong>方法二</strong>与<strong>方法三</strong>只初始化一次数组，重用内存，减少分配开销。</li></ul></li></ol><hr><h2 id="案例教程：滑动窗口算法实战"><a href="#案例教程：滑动窗口算法实战" class="headerlink" title="案例教程：滑动窗口算法实战"></a>案例教程：滑动窗口算法实战</h2><p>以<strong>方法二</strong>为例，逐步解析运行过程：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入 s = &quot;abca&quot;</span><br><span class="line">初始化: count[&#x27;a&#x27;]=0,count[&#x27;b&#x27;]=0,... l=0, ans=0</span><br><span class="line">r=0: s[0]=&#x27;a&#x27; -&gt; count[&#x27;a&#x27;]++ =&gt; 1, ans=max(0,1)=1</span><br><span class="line">r=1: s[1]=&#x27;b&#x27; -&gt; count[&#x27;b&#x27;]++ =&gt; 1, ans=max(1,2)=2</span><br><span class="line">r=2: s[2]=&#x27;c&#x27; -&gt; count[&#x27;c&#x27;]++ =&gt; 1, ans=max(2,3)=3</span><br><span class="line">r=3: s[3]=&#x27;a&#x27; -&gt; count[&#x27;a&#x27;]++ =&gt; 2 -&gt; 重复，进入 while:</span><br><span class="line">    l=0 -&gt; count[&#x27;a&#x27;]-- =&gt;1, l=1 -&gt; 退出 while，窗口 = [1,3]</span><br><span class="line">更新 ans=max(3,3)=3</span><br><span class="line">最终返回 3</span><br></pre></td></tr></table></figure><hr><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="方法二：滑动窗口-1"><a href="#方法二：滑动窗口-1" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| start l=0, r遍历至n |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | count[s[r]]++ |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | count&gt;1 ?    |--是--&gt; [-- l移动, count[s[l]]--, goto判断 --]</span><br><span class="line">    |             |  否</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 更新 ans     |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | r++ 继续     |</span><br><span class="line">    +--------------+</span><br></pre></td></tr></table></figure><h3 id="方法三：优化滑动窗口"><a href="#方法三：优化滑动窗口" class="headerlink" title="方法三：优化滑动窗口"></a>方法三：优化滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">| 初始化 start=0, lastSeen=-1 |</span><br><span class="line">+----------+--------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 遍历 i from 0|</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 新start = max(start, lastSeen[s[i]]+1) |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 更新 ans = max(ans, i-start+1)         |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | lastSeen[s[i]] = i                    |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | i++ 继续                               |</span><br><span class="line">    +--------------+</span><br></pre></td></tr></table></figure><hr><h2 id="相关建议与扩展"><a href="#相关建议与扩展" class="headerlink" title="相关建议与扩展"></a>相关建议与扩展</h2><ul><li><strong>代码优化：</strong> 在C++中，可以使用 <code>array&lt;int, 256&gt;</code> 替代 <code>vector</code> 以进一步提高性能。  </li><li><strong>Unicode 支持：</strong> 若字符串包含宽字符（如中文），需使用 <code>unordered_map&lt;char32_t,int&gt;</code> 或者对UTF-8字节流逐字节处理。  </li><li><strong>在线测试：</strong> 在多组测试用例下测量执行时间，可使用谷歌<strong>Benchmark</strong>库评估微观性能。</li></ul><hr><h2 id="作者想说的话："><a href="#作者想说的话：" class="headerlink" title="作者想说的话："></a><span style="color:#000080;">作者想说的话：</span></h2><p>这道题是字符串滑动窗口的经典示例，推荐掌握<strong>方法三</strong>作为最佳方案。</p><p>更多字符串变体练习：  </p><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/"><span style="color:#2E8B57;">最长回文子串（Longest Palindromic Substring）</span></a>  </li><li><a href="https://leetcode.cn/problems/minimum-window-substring/"><span style="color:#2E8B57;">最小覆盖子串（Minimum Window Substring）</span></a>  </li><li><a href="https://leetcode.cn/problems/permutation-in-string/"><span style="color:#2E8B57;">字符串的排列（Permutation in String）</span></a>  </li><li><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/"><span style="color:#2E8B57;">最长重复字符替换（Longest Repeating Character Replacement）</span></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-2.两数相加（Add Two Numbers）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-20</p></blockquote><h1 id="2-两数相加（Add-Two-Numbers）"><a href="#2-两数相加（Add-Two-Numbers）" class="headerlink" title="2. 两数相加（Add Two Numbers）"></a><a href="https://leetcode.cn/problems/add-two-numbers/"><span style="color:#1E90FF;">2. 两数相加（Add Two Numbers）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color:#228B22;">中等</span></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。  </p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747730875/d358d38d-28d0-4a61-b425-6a0cc98118a9.png" alt="示例图片"><br><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[7,0,8]</code></span><br><strong>解释：</strong> 342 + 465 &#x3D; 807</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [0]</code>, <code>l2 = [0]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[0]</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [9,9,9,9,9,9,9]</code>, <code>l2 = [9,9,9,9]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[8,9,9,9,0,0,0,1]</code></span><br><strong>解释：</strong> 9999999 + 9999 &#x3D; 10009998</p><hr><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h3><ul><li><span style="color:#2E8B57;">每个链表中的节点数在范围 <code>[1, 100]</code> 内</span>  </li><li><span style="color:#2E8B57;">0 &lt;&#x3D; Node.val &lt;&#x3D; 9</span>  </li><li><span style="color:#2E8B57;">题目数据保证列表表示的数字不含前导零</span></li></ul><hr><h2 id="方法一：模拟加法（推荐）"><a href="#方法一：模拟加法（推荐）" class="headerlink" title="方法一：模拟加法（推荐）"></a><span style="color:#8B0000;">方法一：模拟加法（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(max(m, n))  </li><li><strong>空间复杂度：</strong> O(max(m, n))</li></ul><p><strong>思路：</strong><br>逐位相加并维护进位，利用哑节点简化链表操作。该方法所有运算均发生在寄存器和简单指针运算层面，仅在创建新节点时触发堆分配，性能稳定，推荐首选。</p><hr><h2 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a><span style="color:#8B0000;">方法二：递归实现</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">add</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        node-&gt;next = <span class="built_in">add</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>,</span><br><span class="line">                         l2 ? l2-&gt;next : <span class="literal">nullptr</span>,</span><br><span class="line">                         sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(max(m, n))  </li><li><strong>空间复杂度：</strong> O(max(m, n))（递归栈空间）</li></ul><p><strong>思路：</strong><br>将每一位相加的逻辑递归下沉，递归栈负责维护进位和返回，代码简洁。但受限于系统栈深度，不宜用于特别长的链表。</p><hr><h2 id="方法三：使用栈（适用于正序存储）"><a href="#方法三：使用栈（适用于正序存储）" class="headerlink" title="方法三：使用栈（适用于正序存储）"></a><span style="color:#8B0000;">方法三：使用栈（适用于正序存储）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123; s<span class="number">1.</span><span class="built_in">push</span>(l1-&gt;val); l1 = l1-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123; s<span class="number">2.</span><span class="built_in">push</span>(l2-&gt;val); l2 = l2-&gt;next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>() || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = s<span class="number">1.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">1.</span><span class="built_in">top</span>(); <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = s<span class="number">2.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">2.</span><span class="built_in">top</span>(); <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            node-&gt;next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(m + n)  </li><li><strong>空间复杂度：</strong> O(m + n)</li></ul><p><strong>思路：</strong><br>先反转链表至正序，利用显式栈缓存各位数字，再完成加法后恢复逆序。适合链表已正序存储或需保留原链表不变的场景。</p><hr><h2 id="算法底层原理与性能优化"><a href="#算法底层原理与性能优化" class="headerlink" title="算法底层原理与性能优化"></a><span style="color:#2E8B57;">算法底层原理与性能优化</span></h2><p><strong>寄存器与内存分配</strong>  </p><ul><li>简单整数加法与指针操作均在 CPU 寄存器中完成，流水线友好。  </li><li>堆上对象（ListNode）频繁分配会产生系统调用开销，可通过对象池复用减少成本。</li></ul><p><strong>递归栈 vs 显式栈</strong>  </p><ul><li>递归受限于系统栈深度且每层额外保存返回地址及参数；显式栈分配更可控且缓存局部性更好。</li></ul><p><strong>缓存局部性与对象池</strong>  </p><ul><li>链表节点散落在堆中，容易发生缓存未命中；使用对象池可集中分配、提高缓存命中率。</li></ul><p><strong>并行化思考</strong>  </p><ul><li>对于超长向量加法，可考虑 SIMD；链表场景下收益有限，通常不建议。</li></ul><hr><h2 id="模拟加法（迭代）流程图"><a href="#模拟加法（迭代）流程图" class="headerlink" title="模拟加法（迭代）流程图"></a><span style="color:#DAA520;">模拟加法（迭代）流程图</span></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|    开始 addTwoNumbers     |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 初始化 dummy, p, carry=0  |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| l1/l2 任一不空或 carry=1? - No -&gt; 返回 dummy.next</span><br><span class="line">+------------+-+------------+</span><br><span class="line">             |</span><br><span class="line">            Yes</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| x = l1?l1-&gt;val:0, y = ...  |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| sum = x+y+carry           |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| carry = sum/10            |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 新节点 val=sum%10         |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| p-&gt;next=node; p=node      |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| l1?l1=l1-&gt;next, l2同理    |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">           重复循环</span><br></pre></td></tr></table></figure><hr><h2 id="对象池优化示例（伪码）"><a href="#对象池优化示例（伪码）" class="headerlink" title="对象池优化示例（伪码）"></a><span style="color:#4682B4;">对象池优化示例（伪码）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNodePool</span> &#123;</span><br><span class="line">    std::vector&lt;ListNode*&gt; pool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">alloc</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pool.<span class="built_in">back</span>(); pool.<span class="built_in">pop_back</span>();</span><br><span class="line">            node-&gt;val = v; node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListNode</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        pool.<span class="built_in">push_back</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">fastAdd</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNodePool pool;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *p </span>= &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">auto</span> node = pool.<span class="built_in">alloc</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p-&gt;next = node; p = node;</span><br><span class="line">        <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>作者想说的话：</em><br>“两数相加”作为链表模拟经典题，不仅要掌握三种常见解法，更需理解底层运行原理与优化思路，才能在面试和工程实践中游刃有余。</p><p>推荐拓展练习：<a href="https://leetcode.cn/problems/add-two-numbers-ii/">力扣 445. 两数相加 II</a>（正序版本）。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目推荐-SDL太空战机射击游戏(SDLShooter)</title>
      <link href="/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/"/>
      <url>/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-19</p></blockquote><h1 align="center" style="color:#1E90FF;">🚀 推荐项目：SDL 太空战机射击游戏</h1><h2 id="🧭-项目简介"><a href="#🧭-项目简介" class="headerlink" title="🧭 项目简介"></a>🧭 项目简介</h2><ul><li><strong>项目名称</strong>：<strong>SDLShooter</strong>（太空战机射击游戏）  </li><li><strong>教程主页</strong>：👉 <a href="https://cppgamedev.top/courses/sdl-space-shooter">https://cppgamedev.top/courses/sdl-space-shooter</a>  </li><li><strong>源项目仓库</strong>：🔗 <a href="https://github.com/WispSnow/SDLShooter">github.com&#x2F;WispSnow&#x2F;SDLShooter</a>  </li><li><strong>我的个性化版本(持续学习并更新中)</strong>：✨ <a href="https://github.com/1solovedeng/SDLShooter">github.com&#x2F;1solovedeng&#x2F;SDLShooter</a>  </li><li><strong>开源协议</strong>：🆓 <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0-1.0（公有领域，无需署名）</a></li></ul><hr><h2 id="🧑‍💻-为什么推荐这个项目给初学者？"><a href="#🧑‍💻-为什么推荐这个项目给初学者？" class="headerlink" title="🧑‍💻 为什么推荐这个项目给初学者？"></a>🧑‍💻 <span style="color:#FF6600;"><strong>为什么推荐这个项目给初学者？</strong></span></h2><ol><li>🛠️ <span style="color:#00BFFF;"><strong>跨平台、零门槛</strong></span>：基于 SDL2&#x2F;SDL3，支持 Windows &#x2F; Linux &#x2F; macOS，全平台开发无压力。  </li><li>🧩 <span style="color:#32CD32;"><strong>模块化教程</strong></span>：每个章节配有文字+视频教学，对应源码分支一一匹配，方便跟进。  </li><li>🔍 <span style="color:#FF1493;"><strong>实战 + 原理结合</strong></span>：涵盖图形渲染、输入处理、碰撞检测、资源加载等游戏开发核心。  </li><li>📦 <span style="color:#FFA500;"><strong>内置丰富素材</strong></span>：内含音乐、音效、精灵图、爆炸特效、字体，无需再东找西找。  </li><li>🌱 <span style="color:#8A2BE2;"><strong>超自由授权</strong></span>：CC0 许可可商用可二创，想怎么玩都行！</li></ol><hr><h2 id="🌟-项目亮点展示"><a href="#🌟-项目亮点展示" class="headerlink" title="🌟 项目亮点展示"></a>🌟 <span style="color:#DC143C;"><strong>项目亮点展示</strong></span></h2><ul><li>🎮 <span style="color:#FF4500;"><strong>完整功能</strong></span>：主菜单、敌机 AI、爆炸特效、子弹发射、BGM 等典型系统一应俱全。  </li><li>🖼️ <span style="color:#1E90FF;"><strong>高质量素材包整合</strong></span>：以下资源全部 CC0 免费可用：  <ul><li>飞机素材：<a href="https://anim86.itch.io/space-shoter-starter-pack">anim86.itch.io</a>  </li><li>UI 血条：<a href="https://doshrosity.itch.io/32x32-health-ui">doshrosity.itch.io</a>  </li><li>音效包：<a href="https://enprimer.itch.io/spaceship-sound-effects-pack">enprimer.itch.io</a>  </li><li>音乐包：<a href="https://leohpaz.itch.io/space-music-pack">leohpaz.itch.io</a>  </li><li>像素字体：<a href="https://timothyqiu.itch.io/vonwaon-bitmap">timothyqiu.itch.io</a>  </li><li>爆炸特效：<a href="https://ansimuz.itch.io/explosion-animations-pack">ansimuz.itch.io</a></li></ul></li><li>🧠 <span style="color:#20B2AA;"><strong>面向学习设计</strong></span>：每章节分支 <code>chapter-x</code> 可一键跳转当前进度，边学边练最舒适。  </li><li>💡 <span style="color:#FF69B4;"><strong>高度可扩展性</strong></span>：源码清晰，便于添加关卡系统、武器升级、多玩家或联网功能。</li></ul><hr><h2 id="🛠️-环境配置指南"><a href="#🛠️-环境配置指南" class="headerlink" title="🛠️ 环境配置指南"></a>🛠️ 环境配置指南</h2><h3 id="🔵-Linux（Ubuntu）"><a href="#🔵-Linux（Ubuntu）" class="headerlink" title="🔵 Linux（Ubuntu）"></a>🔵 Linux（Ubuntu）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install cmake libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev</span><br></pre></td></tr></table></figure><h3 id="🍎-macOS（基于-Homebrew）"><a href="#🍎-macOS（基于-Homebrew）" class="headerlink" title="🍎 macOS（基于 Homebrew）"></a>🍎 macOS（基于 Homebrew）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake sdl2 sdl2_image sdl2_mixer sdl2_ttf</span><br></pre></td></tr></table></figure><h3 id="🪟-Windows（推荐使用-Visual-Studio-或-VSCode）"><a href="#🪟-Windows（推荐使用-Visual-Studio-或-VSCode）" class="headerlink" title="🪟 Windows（推荐使用 Visual Studio 或 VSCode）"></a>🪟 Windows（推荐使用 Visual Studio 或 VSCode）</h3><ol><li>安装 <strong>Visual Studio 生成工具</strong>（或使用 VS2022）。  </li><li>下载 SDL2、SDL2_image、SDL2_mixer、SDL2_ttf 的 MSVC 版本。  </li><li>将 SDL <code>主文件夹路径</code> 与 <code>lib\x64</code> 添加到系统 PATH。  </li><li>使用 CMake 构建项目即可。</li></ol><hr><h2 id="🚀-快速开始（命令行方式）"><a href="#🚀-快速开始（命令行方式）" class="headerlink" title="🚀 快速开始（命令行方式）"></a>🚀 快速开始（命令行方式）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/WispSnow/SDLShooter.git</span><br><span class="line"><span class="built_in">cd</span> SDLShooter</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./SDLShooter</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>提示</strong>：也可以用 Visual Studio、CLion、VSCode 等 IDE 直接打开项目。</p></blockquote><hr><h2 id="🔧-我的个性版本（持续学习并更新中）"><a href="#🔧-我的个性版本（持续学习并更新中）" class="headerlink" title="🔧 我的个性版本（持续学习并更新中）"></a>🔧 我的个性版本（持续学习并更新中）</h2><p>📌 欢迎查看我的个性化实现和改进版：<a href="https://github.com/1solovedeng/SDLShooter">https://github.com/1solovedeng/SDLShooter</a></p><hr><h2 id="🎯-适合谁？"><a href="#🎯-适合谁？" class="headerlink" title="🎯 适合谁？"></a>🎯 <span style="color:#00CED1;"><strong>适合谁？</strong></span></h2><ul><li>📚 C++ 初学者，希望快速建立完整项目经验  </li><li>🎮 对游戏开发感兴趣，想了解从零构建一个 2D 游戏的全过程  </li><li>💡 想基于 SDL 引擎进行拓展开发，如 AI、粒子、物理、地图编辑器等</li></ul><hr><h2 id="🏁-总结"><a href="#🏁-总结" class="headerlink" title="🏁 总结"></a>🏁 总结</h2><p>🎉 <strong>SDLShooter</strong> 是一个集实战、学习、素材、授权于一体的超强新手项目。<br>🎯 如果你正在寻找一个能立刻投入实践、同时能打通 SDL 知识体系的项目，它就是你的最佳选择！<br>🛠️ 动手开发，<span style="color:#32CD32;"><strong>从这款射击游戏开始你的 C++ 游戏开发之路！</strong></span></p><hr><h2 id="🔍-算法原理与优化"><a href="#🔍-算法原理与优化" class="headerlink" title="🔍 算法原理与优化"></a>🔍 算法原理与优化</h2><p>在一个 2D 射击游戏中，核心算法直接影响运行速度和内存使用。下面我们将针对三种关键算法：游戏主循环（Game Loop）、碰撞检测（AABB 算法）、资源管理（对象池算法），分别说明思路、流程图、原理注释，并从计算机原理角度分析其时间复杂度与空间复杂度。</p><h3 id="1-游戏主循环（Game-Loop-固定时间步长算法）"><a href="#1-游戏主循环（Game-Loop-固定时间步长算法）" class="headerlink" title="1. 游戏主循环（Game Loop 固定时间步长算法）"></a>1. 游戏主循环（Game Loop 固定时间步长算法）</h3><p><strong>思路</strong>：  </p><ul><li>保持稳定的游戏帧率，避免不同硬件导致的速度不一致。  </li><li>将更新步骤与渲染步骤分离，使用固定时间步长（如 16ms&#x2F;帧），在一帧内可多次更新或跳帧渲染。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> MS_PER_UPDATE = <span class="number">16.6667</span>; <span class="comment">// 60 FPS</span></span><br><span class="line"><span class="type">double</span> previous = <span class="built_in">SDL_GetTicks</span>();</span><br><span class="line"><span class="type">double</span> lag = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="type">double</span> current = <span class="built_in">SDL_GetTicks</span>();</span><br><span class="line">    <span class="type">double</span> elapsed = current - previous;</span><br><span class="line">    previous = current;</span><br><span class="line">    lag += elapsed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processInput</span>(); <span class="comment">// 处理玩家输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lag &gt;= MS_PER_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">update</span>();    <span class="comment">// 更新游戏逻辑</span></span><br><span class="line">        lag -= MS_PER_UPDATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(interpolation = lag / MS_PER_UPDATE); <span class="comment">// 渲染并插值动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ 开始主循环 │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────────┐</span><br><span class="line">│ 获取当前时间  │</span><br><span class="line">│ current = t   │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌────────────────────────┐</span><br><span class="line">│ 计算 elapsed =         │</span><br><span class="line">│ current - previous     │</span><br><span class="line">└─────┬─────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────────┐</span><br><span class="line">│ lag += elapsed │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│ 处理玩家输入 │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│ while (lag &gt;= MS_PER_UPDATE) &#123;     │</span><br><span class="line">│     update();                      │</span><br><span class="line">│     lag -= MS_PER_UPDATE;          │</span><br><span class="line">│ &#125;                                   │</span><br><span class="line">└─────┬──────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│ render(interpolation)    │</span><br><span class="line">└─────┬───────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│ previous = current       │</span><br><span class="line">└─────┬───────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────┐</span><br><span class="line">│ 回到第1步 │</span><br><span class="line">└───────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>使用 SDL_GetTicks() 获取毫秒计时，依赖硬件计时器。  </li><li>固定时间步长避免物理计算的抖动与不一致。  </li><li>插值渲染（interpolation）减少渲染抖动。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／帧，每帧固定更新次数，最坏情况下渲染略有抖动。  </li><li>空间复杂度：O(1)，常量内存使用。  </li><li><strong>计算机原理</strong>：减少分支跳转，提高 CPU 分支预测命中率；固定循环结构也有助于缓存友好，从而提高管线吞吐。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658297/41480e08-883a-470a-9eb9-a42b4d81053b.png" alt="主循环示例"></p><ul><li>图：主循环示例</li></ul><hr><h3 id="2-碰撞检测（轴对齐包围盒-AABB-算法）"><a href="#2-碰撞检测（轴对齐包围盒-AABB-算法）" class="headerlink" title="2. 碰撞检测（轴对齐包围盒 AABB 算法）"></a>2. 碰撞检测（轴对齐包围盒 AABB 算法）</h3><p><strong>思路</strong>：  </p><ul><li>为每个精灵创建一个矩形边界；  </li><li>通过比较矩形的 x 和 y 范围来判断是否相交。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AABB</span><span class="params">(<span class="type">const</span> Rect&amp; a, <span class="type">const</span> Rect&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x &lt; b.x + b.w &amp;&amp;</span><br><span class="line">            a.x + a.w &gt; b.x &amp;&amp;</span><br><span class="line">            a.y &lt; b.y + b.h &amp;&amp;</span><br><span class="line">            a.y + a.h &gt; b.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图（txt 格式）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│ 取矩形 a 和 b 的   │</span><br><span class="line">│ x, y, w, h         │</span><br><span class="line">└─────────┬──────────┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.x &lt; b.x + b.w ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.x + a.w &gt; b.x ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.y &lt; b.y + b.h ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.y + a.h &gt; b.y ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────────────────────────┐</span><br><span class="line">│ 若上述均为真，则 “碰撞”             │</span><br><span class="line">└─────────┬──────────────────────────┘</span><br><span class="line">          │</span><br><span class="line">         否则</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────────────────────────┐</span><br><span class="line">│ 否则 “无碰撞”                       │</span><br><span class="line">└──────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>通过连续的比较操作，判断两个区间是否重叠。  </li><li>矩形检测分支较少，CPU 分支预测效果好；  </li><li>内存占用小，仅存储四个浮点数或整数。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／两精灵对检测；  </li><li>若检测所有 N 个敌机与子弹对，则最坏为 O(N²)；  </li><li>空间复杂度：O(N)，存储 N 个包围盒。  </li><li><strong>计算机原理</strong>：数据存连续存储，可利用缓存行；简单算术与逻辑运算很少访存；分支较少可极大提升流水线利用率。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658477/ebab4866-7af8-4e6c-bb80-4c23b2686f17.png" alt="AABB 碰撞示意图"></p><ul><li>图：AABB碰撞示意图</li></ul><hr><h3 id="3-资源管理（对象池-Object-Pool-算法）"><a href="#3-资源管理（对象池-Object-Pool-算法）" class="headerlink" title="3. 资源管理（对象池 Object Pool 算法）"></a>3. 资源管理（对象池 Object Pool 算法）</h3><p><strong>思路</strong>：  </p><ul><li>预先分配固定大小的对象池，避免频繁 new&#x2F;delete 或 malloc&#x2F;free 导致的内存碎片化和性能波动；  </li><li>通过栈或链表管理空闲对象，获取和归还操作均为 O(1)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 可扩展或抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        T* obj = freeList.<span class="built_in">back</span>();</span><br><span class="line">        freeList.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(T* obj)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push_back</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T*&gt; freeList;</span><br><span class="line">    std::unique_ptr&lt;T[]&gt; pool; <span class="comment">// 实际存储</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图（txt 格式）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ 初始化：分配连续内存 pool，所有对象入栈 freeList │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ acquire():                                 │</span><br><span class="line">│   从 freeList 弹出一个对象                  │</span><br><span class="line">│   返回给调用者                              │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ release(obj):                              │</span><br><span class="line">│   将 obj 推入 freeList                      │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ 结束                                     │</span><br><span class="line">└─────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>预分配的连续内存块减少碎片；  </li><li>std::vector 管理的 freeList 保证快速索引；  </li><li>避免动态分配带来的系统调用开销。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／次；  </li><li>空间复杂度：O(N)，预分配 N 个对象；  </li><li><strong>计算机原理</strong>：连续内存利于缓存；减少系统调用和堆管理锁竞争；极大提高运行稳定性。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658746/cbfa370a-7f8a-4708-83c7-e28b5c0201be.png" alt="对象池示意图"></p><hr><h2 id="📚-深度学习教程推荐"><a href="#📚-深度学习教程推荐" class="headerlink" title="📚 深度学习教程推荐"></a>📚 深度学习教程推荐</h2><ul><li><strong>Game Loop 详解</strong>：  <ul><li>《Game Programming Patterns》中的 <a href="https://gameprogrammingpatterns.com/game-loop.html">Game Loop 一章</a></li></ul></li><li><strong>碰撞检测优化</strong>：  <ul><li>AABB、Sweep and Prune 等多种方法比较：<a href="https://gamedevelopment.tutsplus.com/tutorials">博客链接</a></li></ul></li><li><strong>对象池最佳实践</strong>：  <ul><li>《C++ Concurrency in Action》中资源管理章节</li></ul></li></ul><p>以上三种算法是任何 2D 游戏的基础，了解其原理并掌握优化策略，对性能提升与稳定性保障至关重要。</p><hr><h2 align="center" style="color:#FF8C00;">🌌 Happy Coding & Enjoy Shooting! 🌌</h2>]]></content>
      
      
      <categories>
          
          <category> ProjectPicks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDL </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-1.两数之和（Two Sum）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-18</p></blockquote><h1 id="1-两数之和（Two-Sum）"><a href="#1-两数之和（Two-Sum）" class="headerlink" title="1. 两数之和（Two Sum）"></a><a href="https://leetcode.cn/problems/two-sum/"><span style="color:#1E90FF;">1. 两数之和（Two Sum）</span></a></h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a><span style="color:#228B22;">简单</span></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><strong>输出：</strong> <span style="color:#FF4500;">[0,1]</span><br><strong>解释：</strong> 因为 <span style="color:#DAA520;">nums[0] + nums[1] &#x3D;&#x3D; 9</span>，返回 <span style="color:#DAA520;">[0, 1]</span>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [3,2,4], target &#x3D; 6</span><br><strong>输出：</strong> <span style="color:#FF4500;">[1,2]</span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [3,3], target &#x3D; 6</span><br><strong>输出：</strong> <span style="color:#FF4500;">[0,1]</span></p><hr><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h3><ul><li><span style="color:#2E8B57;">2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</span>  </li><li><span style="color:#2E8B57;">-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</span>  </li><li><span style="color:#2E8B57;">-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</span>  </li><li><span style="color:#2E8B57;">只会存在一个有效答案</span></li></ul><hr><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a><span style="color:#FF8C00;">进阶：</span></h3><p>你可以想出一个时间复杂度小于 <span style="color:#2F4F4F;">O(n^2)</span> 的算法吗？</p><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">47ms</span>，击败 <span style="color:#8B0000;">28.79%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">13.80MB</span>，击败 <span style="color:#8B0000;">83.42%</span></li></ul><p><strong>思路：</strong><br>嵌套两个循环，枚举数组中每一对 (i, j)，检查 <span style="color:#DAA520;">nums[i] + nums[j] &#x3D;&#x3D; target</span> 时立即返回下标。不使用额外空间，直观易实现，但在 n 较大时性能迅速下降。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ Start     │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i=0, j=1</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Check sum │</span><br><span class="line">│ nums[i]+  │</span><br><span class="line">│ nums[j]   │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ == target?</span><br><span class="line"> ┌────▼────┐      ┌───────────┐</span><br><span class="line"> │ Yes     │────▶│ Return    │</span><br><span class="line"> │         │      │ &#123;i, j&#125;    │</span><br><span class="line"> └────▲────┘      └───────────┘</span><br><span class="line">      │ No</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ j++ or    │</span><br><span class="line">│ i++, reset│</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ Continue</span><br><span class="line">      ▼</span><br><span class="line">    End loop</span><br></pre></td></tr></table></figure><hr><h2 id="方法二：二次遍历哈希表"><a href="#方法二：二次遍历哈希表" class="headerlink" title="方法二：二次遍历哈希表"></a><span style="color:#8B0000;">方法二：二次遍历哈希表</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 第一次遍历：填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lookup[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次遍历：找补数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> c = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">7ms</span>，击败 <span style="color:#8B0000;">43.89%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">15.74MB</span>，击败 <span style="color:#8B0000;">5.38%</span></li></ul><p><strong>思路：</strong><br>利用哈希表在 O(1) 平均时间内完成查找。第一次遍历将元素值映射到下标，第二次遍历寻找补数并验证。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ Start     │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i=0</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Fill map  │</span><br><span class="line">│ lookup[   │</span><br><span class="line">│ nums[i]]=i│</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i&lt;n?</span><br><span class="line"> ┌────▼────┐      ┌────────┐</span><br><span class="line"> │ Yes     │────▶│Continue│</span><br><span class="line"> └────▲────┘      └────────┘</span><br><span class="line">      │ No</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ j=0       │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Find c    │</span><br><span class="line">│ c=target- │</span><br><span class="line">│ nums[j]   │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ found?</span><br><span class="line">┌─────▼─────┐      ┌────────┐</span><br><span class="line">│ Yes       │────▶│ Return │</span><br><span class="line">│           │      │ &#123;j,it &#125;│</span><br><span class="line">└─────┬─────┘      └────────┘</span><br><span class="line">      │ No</span><br><span class="line">      ▼</span><br><span class="line">    j++, loop</span><br></pre></td></tr></table></figure><hr><h2 id="方法三：一次遍历哈希表（相对最优解）"><a href="#方法三：一次遍历哈希表（相对最优解）" class="headerlink" title="方法三：一次遍历哈希表（相对最优解）"></a><span style="color:#8B0000;">方法三：一次遍历哈希表（相对最优解）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;              <span class="comment">// 准备一个空的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 遍历每个元素</span></span><br><span class="line">            <span class="type">int</span> complement = target - nums[i];       <span class="comment">// 计算补数</span></span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(complement);       <span class="comment">// 在哈希表中查找补数</span></span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>()) &#123;               <span class="comment">// 若找到了</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;              <span class="comment">// 立即返回“补数的下标 + 当前下标”</span></span><br><span class="line">            &#125;</span><br><span class="line">            lookup[nums[i]] = i;                     <span class="comment">// 否则，将当前元素插入哈希表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">0ms</span>，击败 <span style="color:#8B0000;">100.00%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">14.55MB</span>，击败 <span style="color:#8B0000;">45.96%</span></li></ul><p><strong>思路：</strong><br>在同一次遍历中完成查找与插入操作，边遍历边搜索，降低了常数开销，是最优实践。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌────────────┐</span><br><span class="line">│ Start      │</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ i=0</span><br><span class="line">┌──────▼─────┐</span><br><span class="line">│ Compute    │</span><br><span class="line">│ complement │</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ lookup.find?</span><br><span class="line">┌──────▼─────┐      ┌──────────┐</span><br><span class="line">│ Found?     │────▶│ Return   │</span><br><span class="line">│ it!=end    │      │ &#123;pos,i&#125;  │</span><br><span class="line">└──────┬─────┘      └──────────┘</span><br><span class="line">       │ No</span><br><span class="line">┌──────▼─────┐</span><br><span class="line">│ Insert num │</span><br><span class="line">│ lookup[val]│</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ Continue</span><br><span class="line">       ▼</span><br><span class="line">     End loop</span><br></pre></td></tr></table></figure><hr><h2 id="算法原理与性能分析"><a href="#算法原理与性能分析" class="headerlink" title="算法原理与性能分析"></a>算法原理与性能分析</h2><ol><li><p><strong>计算机层面运行原理</strong>  </p><ul><li><strong>CPU 指令流水线</strong>：在暴力枚举中，分支预测失误成本高，频繁分支跳转导致流水线清空，降低执行效率。哈希查找中分支少，流水线利用率更高。  </li><li><strong>缓存（Cache）命中</strong>：暴力枚举随机访问数组元素，缓存命中率较低；哈希表操作也有随机访问，但现代 CPU L1&#x2F;L2 缓存可加速哈希桶的访问。  </li><li><strong>内存分配与扩展</strong>：哈希表在增长时需要重新分配和再哈希，开销为 O(n)，但摊销到每次插入时均摊为 O(1)。</li></ul></li><li><p><strong>时间复杂度分析</strong>  </p><ul><li>暴力枚举：O(n²)，随着 n 增大，运算量急剧上升。  </li><li>二次遍历哈希：O(n) + O(n) &#x3D; O(n)，额外遍历构建和查找。  </li><li>一次遍历哈希：O(n) 平均，最坏 O(n²)（所有元素哈希冲突时）。</li></ul></li><li><p><strong>空间复杂度分析</strong>  </p><ul><li>暴力枚举：O(1)，无额外存储。  </li><li>哈希表方法：O(n)，需存储 n 个键值对。  </li><li>空间换时间策略：在内存充足时，优先考虑哈希方法。</li></ul></li><li><p><strong>实践建议</strong>  </p><ul><li>对于小规模数组（n &lt; 1000），暴力枚举也能在毫秒级完成。  </li><li>对于大规模数据，推荐一次遍历哈希，保证线性性能。  </li><li>若内存敏感，可考虑空间占用更小的排序加双指针方案，但不适用于无序数组的索引返回。</li></ul></li></ol><hr><h2 id="教程与扩展"><a href="#教程与扩展" class="headerlink" title="教程与扩展"></a>教程与扩展</h2><ol><li><p><strong>详细步骤</strong>  </p><ul><li>理解题意：需要返回下标，对数组进行两两组合或查找补数。  </li><li>选择合适的数据结构：哈希表对于查找补数是最合适的。  </li><li>编码实现：注意边界条件与哈希冲突。  </li><li>测试用例：考虑正负数、重复元素、目标值为 0 等。</li></ul></li><li><p><strong>可视化教程</strong>  </p><h2 id="线性探测插入流程详解"><a href="#线性探测插入流程详解" class="headerlink" title="线性探测插入流程详解"></a>线性探测插入流程详解</h2></li></ol><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747581726/b79aa1fde303b05cdba669f5eb6b60ae_tydwtx.gif"></p><h2 id="哈希表插入示例"><a href="#哈希表插入示例" class="headerlink" title="哈希表插入示例"></a>哈希表插入示例</h2><p>① <strong>插入第一个元素</strong>  </p><ul><li>将键值对 <code>(7, &quot;seven&quot;)</code> 准备插入哈希表。  </li><li>通过哈希函数计算，得到目标下标为 <code>0</code>。  </li><li>检查哈希表索引 <code>0</code> 处，当前为空槽，所以直接在此位置存放 <code>(7, &quot;seven&quot;)</code>。</li></ul><p>② <strong>插入第二个元素</strong>  </p><ul><li>将键值对 <code>(14, &quot;fourteen&quot;)</code> 准备插入哈希表。  </li><li>经过同样的哈希映射，也得到下标 <code>0</code>。  </li><li>发现位置 <code>0</code> 已被占用，需要寻找下一个可用槽。</li></ul><p>③ <strong>线性探测寻址</strong>  </p><ul><li>从冲突下标 <code>0</code> 开始，依次往后探查：  <ol><li>检查下标 <code>1</code>，若为空则将 <code>(14, &quot;fourteen&quot;)</code> 存入；  </li><li>若下标 <code>1</code> 也已占用，则继续检查下标 <code>2</code>、<code>3</code>……</li></ol></li><li>直到遇到第一个空槽，将该键值对存储于此。</li></ul><hr><p><strong>说明：</strong>  </p><ul><li>本示例采用“线性探测”（Linear Probing）法来处理哈希冲突；  </li><li>如果探测到数组末尾仍未找到空槽，可认为哈希表已满，或采取环绕回到数组开头的方式继续探测。</li></ul><hr><p><strong>实践练习</strong>  </p><ul><li>变体题目：<a href="https://leetcode.cn/problems/3sum/description/">三数之和 Three Sum</a>、和<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">为 K 的子数组 Subarray Sum</a> 等。  </li><li>针对排序数组：使用双指针法。  </li><li>考虑多目标时的通用解决方案。</li></ul><hr><p><em>作者想说的话：</em><br>“两数之和（Two Sum）” 是经典入门题，这三种解法体现了解题思路的演进。深入理解算法底层原理，有助于在面试和工程实践中快速做出最佳选择。  </p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具-Dev-C++</title>
      <link href="/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/"/>
      <url>/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于 2025-5-18</p></blockquote><h1 id="🛠️-推荐工具：Dev-C"><a href="#🛠️-推荐工具：Dev-C" class="headerlink" title="🛠️ 推荐工具：Dev-C++"></a>🛠️ 推荐工具：Dev-C++</h1><p><strong>Dev-C++</strong> 是一款轻量级、免费开源的 C&#x2F;C++ 集成开发环境（IDE），内置 GCC 编译器，适用于 Windows 系统。其界面简洁、操作直观，尤其适合 C&#x2F;C++ 初学者使用。</p><h2 id="✅-主要特点"><a href="#✅-主要特点" class="headerlink" title="✅ 主要特点"></a>✅ 主要特点</h2><ul><li><strong>语法高亮与代码补全</strong>：支持语法高亮显示和自动代码补全，减少编辑错误，提高编码效率。</li><li><strong>多语言支持</strong>：提供简体中文、繁体中文、英语等多种语言界面，方便不同用户使用。</li><li><strong>内置调试功能</strong>：集成调试器，支持断点设置、变量监视等基本调试操作。</li><li><strong>适合初学者</strong>：操作简便，学习成本低，是学习 C&#x2F;C++ 编程的理想工具。</li><li><strong>集成多种工具</strong>：集合了 MinGW 中的 GCC 编译器、GDB 调试器和 AStyle 格式整理器等自由软件。</li></ul><h2 id="📥-下载地址"><a href="#📥-下载地址" class="headerlink" title="📥 下载地址"></a>📥 下载地址</h2><ul><li>阿里云盘： <a href="https://www.alipan.com/s/JDbA6mR8iVm">点击下载</a></li><li>百度网盘： <a href="https://pan.baidu.com/s/1S4FZFabzbIL2nK_bfe6MNw?pwd=nura">点击下载</a>  <blockquote><p>提取码：<code>nura</code></p></blockquote></li><li>夸克网盘： <a href="https://pan.quark.cn/s/5176261faeae">点击下载</a></li></ul><blockquote><p>⚠️ 如果链接失效，请在评论区留言，我们会及时更新。感谢您的支持与指正！</p></blockquote><h2 id="📚-安装与使用教程"><a href="#📚-安装与使用教程" class="headerlink" title="📚 安装与使用教程"></a>📚 安装与使用教程</h2><ul><li><a href="https://www.dotcpp.com/course/338">Dev-C++ 下载与安装图文教程</a></li><li><a href="https://blog.csdn.net/bigzql/article/details/109349382">Dev-C++ 安装及使用方法教程</a></li></ul><hr><h2 id="⚠️-声明"><a href="#⚠️-声明" class="headerlink" title="⚠️ 声明"></a>⚠️ <strong>声明</strong></h2><p><strong>Dev-C++</strong> 因多年未获持续更新，其核心工具链和功能已显过时，不再适合中大型或需现代 C&#x2F;C++ 特性（如 C++17&#x2F;20、模块化构建、内置包管理等）的项目开发。  </p><blockquote><ul><li><strong>官方原始版</strong>（Bloodshed Software）自 2005 年 2 月 22 日起即停止活跃维护，后续开发主要停滞不前，存在大量已知缺陷难以修复。</li><li><strong>Embarcadero 维护的最新版</strong>（最新 6.3 版本）最后发布于 2021 年 1 月 30 日，且最近一次更新记录为 2021 年 5 月 19 日，距今已逾四年。</li></ul></blockquote><p><strong>建议</strong>  </p><blockquote><ul><li><strong>仅限入门学习</strong>：Dev-C++ 界面简洁、操作直观，适合作为 C&#x2F;C++ 新手的入门练习环境。  </li><li><strong>深入研究</strong>：文中详述的环境配置、项目管理与调试技巧，建议仅用于学习参考及历史研究，若进行实际开发，请优先选择更现代的 IDE，如 <strong>Visual Studio</strong>, <strong>CLion</strong>, <strong>Code::Blocks</strong>, 或基于 <strong>VS Code</strong> 的开发环境。</li></ul></blockquote><hr><h2 id="⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点："><a href="#⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点：" class="headerlink" title="⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点："></a><strong>⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点：</strong></h2><p>① 编辑器默认编码为 ANSI，与源文件或系统不匹配<br>② Console 窗口默认 Code Page 非 UTF-8，导致输出无法正确解码<br>③ 系统语言&#x2F;区域设置不当，可能影响文件打开与显示  </p><p>下面汇总几种常用且高效的解决方案，您可按需任选或组合使用。</p><hr><h2 id="①-更改编辑器默认编码"><a href="#①-更改编辑器默认编码" class="headerlink" title="① 更改编辑器默认编码"></a>① 更改编辑器默认编码</h2><p>a. 打开 Dev-C++，依次点击 <strong>Tools → Editor Options</strong>，在 <strong>General</strong>（或 <strong>Code Generation</strong>）选项卡中，将 <strong>Character set</strong> 从 <strong>ANSI</strong> 改为 <strong>UTF-8</strong> 并确认。<br>b. 关闭当前编辑的文件后重新打开，即可让编辑器以 UTF-8 模式加载和保存文件。</p><hr><h2 id="②-源文件另存为-UTF-8"><a href="#②-源文件另存为-UTF-8" class="headerlink" title="② 源文件另存为 UTF-8"></a>② 源文件另存为 UTF-8</h2><p>a. 在 Dev-C++ 中打开源文件，点击 <strong>File → Save As…</strong><br>b. 在保存对话框的编码选项中，选择 <strong>UTF-8</strong>（无 BOM）后保存。<br>c. 若批量转换，可使用 Notepad++：打开文件 → <strong>Encoding → Convert to UTF-8</strong> → 保存。</p><hr><h2 id="③-利用记事本或-Notepad-转码"><a href="#③-利用记事本或-Notepad-转码" class="headerlink" title="③ 利用记事本或 Notepad++ 转码"></a>③ 利用记事本或 Notepad++ 转码</h2><p>a. <strong>记事本法</strong>：  </p><ul><li>右键目标 <code>.cpp</code>&#x2F;<code>.h</code> 文件 → <strong>打开方式 → 记事本</strong>  </li><li>在记事本中点击 <strong>文件 → 另存为</strong>，选择 <strong>ANSI</strong> 编码保存（覆盖或另存）  </li><li>再用 Dev-C++ 打开，强制以 ANSI 读取，常能规避乱码</li></ul><p>b. <strong>Notepad++ 法</strong>：  </p><ul><li>用 Notepad++ 打开源码 → <strong>Encoding → Convert to UTF-8</strong>（注意非“Encode in UTF-8”）  </li><li>保存后再用 Dev-C++ 正常打开编译</li></ul><hr><h2 id="④-设置-Console-窗口编码"><a href="#④-设置-Console-窗口编码" class="headerlink" title="④ 设置 Console 窗口编码"></a>④ 设置 Console 窗口编码</h2><p>a. 在 Windows 控制台中手动切换：  </p><blockquote><p>chcp 65001</p></blockquote><p>   使当前会话使用 UTF-8 Code Page<br>b. 或修改注册表，永久生效：  </p><ul><li><p>打开 <strong>Regedit</strong>，定位到  </p><blockquote><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\Autorun</p></blockquote><p>新建&#x2F;修改字符串值为：  </p><blockquote><p>@chcp 65001&gt;nul</p></blockquote><p>以后每次打开控制台都会自动切换到 UTF-8</p></li></ul><hr><h2 id="⑤-在代码中显式设置"><a href="#⑤-在代码中显式设置" class="headerlink" title="⑤ 在代码中显式设置"></a>⑤ 在代码中显式设置</h2><p> 在程序入口处调用 Windows API：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="强制控制台以-UTF-8-解码输出"><a href="#强制控制台以-UTF-8-解码输出" class="headerlink" title="   强制控制台以 UTF-8 解码输出"></a>   强制控制台以 UTF-8 解码输出</h2><h2 id="⑥-检查系统语言与区域设置"><a href="#⑥-检查系统语言与区域设置" class="headerlink" title="⑥ 检查系统语言与区域设置"></a>⑥ 检查系统语言与区域设置</h2><p>a. 进入 <strong>控制面板 → 语言和区域设置 → 管理语言设置</strong><br>b. 将“非 Unicode 程序的语言”改为 <strong>中文（简体，中国）</strong>，重启生效<br>c. 确保系统区域、字体均支持中文显示</p><hr><blockquote><p>以上方法可单独或组合使用，通常先保证编辑器和源文件均为 UTF-8，再调整控制台 Code Page，即可彻底解决 Dev-C++ 中文乱码问题。</p></blockquote><hr><h1 id="✅Dev-C-使用方法："><a href="#✅Dev-C-使用方法：" class="headerlink" title="✅Dev-C++使用方法："></a>✅Dev-C++使用方法：</h1><h2 id="1-界面与工作区布局"><a href="#1-界面与工作区布局" class="headerlink" title="1. 界面与工作区布局"></a>1. 界面与工作区布局</h2><p><img src="https://raw.githubusercontent.com/Embarcadero/Dev-Cpp/master/Source/Images/screenshot800x600.png" alt="Dev-C++ 主界面示例"><br><em>图：Dev-C++ 典型代码编辑与输出窗口布局</em>  </p><ol><li><strong>代码编辑区</strong>：左侧显示项目文件树，右侧显示代码编辑窗口。您可以通过拖动标签页，自由切换不同文件。</li><li><strong>输出与调试区</strong>：底部集成 Console 窗口，运行、编译、调试的所有输出都会在此展示，支持清屏和滚动查看。</li><li><strong>工具栏与菜单</strong>：常用操作按钮集中于顶部，包括新建、打开、保存、编译、调试、运行等，鼠标悬停可查看快捷键提示。</li></ol><h2 id="2-项目管理与构建流程"><a href="#2-项目管理与构建流程" class="headerlink" title="2. 项目管理与构建流程"></a>2. 项目管理与构建流程</h2><h3 id="2-1-新建项目"><a href="#2-1-新建项目" class="headerlink" title="2.1 新建项目"></a>2.1 新建项目</h3><ol><li>打开 Dev-C++ 后，依次点击：</li></ol><blockquote><p>File → New → Project</p></blockquote><ol start="2"><li>在弹出的对话框中选择“Console Application”或“GUI Application”，按照向导填写项目名称与保存路径。</li></ol><h3 id="2-2-添加源文件、头文件"><a href="#2-2-添加源文件、头文件" class="headerlink" title="2.2 添加源文件、头文件"></a>2.2 添加源文件、头文件</h3><ul><li>在“Project”窗口右键项目名，选择 <strong>Add to Project → New File</strong>，即可创建新的 <code>.cpp</code> 或 <code>.h</code> 文件。</li><li>若想引入已有文件，则选择 <strong>Add to Project → Add Existing Item</strong>，浏览文件夹并选中即可。</li></ul><h3 id="2-3-编译与链接"><a href="#2-3-编译与链接" class="headerlink" title="2.3 编译与链接"></a>2.3 编译与链接</h3><ul><li>点击工具栏上的 <strong>Compile</strong> (编译) 按钮即可编译当前源文件。</li><li>点击 <strong>Run</strong> (运行) 按钮，Dev-C++ 会先自动编译并链接，然后在下方 Console 窗口中执行。</li><li>若需要只链接不运行，可在菜单中选择 <strong>Execute → Compile &amp; Run Options</strong>，取消“Run after compile”前的勾选。</li></ul><h2 id="3-高级调试技巧"><a href="#3-高级调试技巧" class="headerlink" title="3. 高级调试技巧"></a>3. 高级调试技巧</h2><p><img src="https://img.youtube.com/vi/R5zhpQW-MJk/maxresdefault.jpg" alt="调试断点与变量监视"><br><em>图：设置断点与在“Watches”窗口监视变量值</em></p><ol><li><strong>断点管理</strong>：在代码编辑区左侧行号栏单击，可新增&#x2F;删除断点。</li><li><strong>单步执行</strong>：使用 <strong>Step Into (F7)</strong>、<strong>Step Over (F8)</strong> 等功能逐行跟踪。</li><li><strong>变量监视</strong>：在“Watches”窗口右键 → <strong>Insert Watch</strong>，输入变量名，可动态观察其值变化。</li><li><strong>调用堆栈</strong>：在断点处暂停时，点击“Call Stack”选项卡查看函数调用顺序，快速定位问题源头。</li></ol><h2 id="4-插件与扩展：DevPaks-管理"><a href="#4-插件与扩展：DevPaks-管理" class="headerlink" title="4. 插件与扩展：DevPaks 管理"></a>4. 插件与扩展：DevPaks 管理</h2><ol><li>打开 <strong>Tools → Package Manager</strong>。</li><li>在“Available”选项卡中搜索并安装常用 DevPaks，如：<ul><li>`gtkmm-devpack`：GTK+ C++ 接口支持</li><li>`SDL2-devpack`：简单跨平台多媒体与游戏开发库</li><li>`mysql-devpack`：MySQL 数据库接口</li></ul></li><li>选中目标 DevPak，点击 <strong>Install</strong> 即可一键集成对应头文件和库。</li></ol><blockquote><p><strong>Tip</strong>：若官方仓库中未找到，您也可从 <a href="https://sourceforge.net/projects/devpaks/">SourceForge DevPaks 列表</a> 下载并安装。</p></blockquote><h2 id="5-性能优化与编译选项"><a href="#5-性能优化与编译选项" class="headerlink" title="5. 性能优化与编译选项"></a>5. 性能优化与编译选项</h2><ul><li><strong>Optimization level</strong> (<code>-O0</code>&#x2F;<code>-O1</code>&#x2F;<code>-O2</code>&#x2F;<code>-O3</code>): 开发阶段建议使用 <code>-O0</code> 便于调试；发布阶段可切换到 <code>-O2</code> 或 <code>-O3</code>，提升执行效率。</li><li><strong>Language standard</strong>：支持选择 <code>ISO C++11</code>、<code>ISO C++14</code>、<code>GNU C++17</code> 等，确保与现代编译特性兼容。</li><li><strong>Link-time optimization</strong> (LTO)：启用可在链接阶段进一步优化。</li></ul><h2 id="6-常见问题与解决方案"><a href="#6-常见问题与解决方案" class="headerlink" title="6. 常见问题与解决方案"></a>6. 常见问题与解决方案</h2><table><thead><tr><th>问题描述</th><th>解决方法</th></tr></thead><tbody><tr><td>编译时报 “cannot find -lmingw32”</td><td>检查 MinGW 路径：<code>Tools → Compiler Options → Directories → Libraries</code> 中添加 MinGW 安装目录下的 <code>lib</code></td></tr><tr><td>控制台汉字显示乱码</td><td>右键 Console → Properties → Font 选择 “新宋体” 或 “Consolas”，并确保文件以 UTF-8 编码保存</td></tr><tr><td>插件安装后 IDE 无法启动</td><td>删除 <code>%AppData%\\Dev-Cpp\\</code> 下的配置文件或重新安装对应 DevPak</td></tr><tr><td>调试时无法进入标准库函数</td><td>在 <strong>Project Options → Debugging</strong> 中勾选 “Debug Standard Libraries”</td></tr></tbody></table><h2 id="7-实战案例：使用-OpenCV-进行图像处理"><a href="#7-实战案例：使用-OpenCV-进行图像处理" class="headerlink" title="7. 实战案例：使用 OpenCV 进行图像处理"></a>7. 实战案例：使用 OpenCV 进行图像处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="built_in">imwrite</span>(<span class="string">&quot;output.jpg&quot;</span>, gray);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>安装 <code>opencv-devpack</code>。</li><li>新建 Console 项目，添加代码至 <code>main.cpp</code>。</li><li>链接参数：<code>-lopencv_core -lopencv_imgproc -lopencv_highgui</code>。</li><li>复制 OpenCV <code>bin</code> 下的 <code>.dll</code> 至可执行文件目录。</li><li>点击 <strong>Compile &amp; Run</strong>，查看生成的 <code>output.jpg</code>。</li></ol><h2 id="8-社区与学习资源"><a href="#8-社区与学习资源" class="headerlink" title="8. 社区与学习资源"></a>8. 社区与学习资源</h2><ul><li>官方论坛：Stack Overflow <a href="https://stackoverflow.com/questions/tagged/orwelldevcpp">orwelldevcpp</a></li><li>源码仓库:<a href="https://github.com/Embarcadero/Dev-Cpp">Embarcadero 官方托管（GitHub）</a></li><li>源码仓库:<a href="https://sourceforge.net/projects/orwelldevcpp/files/Source/">Orwell 版本源码快照（SourceForge）</a></li><li>书籍：《C++ Primer 中文版》、《Effective C++》系列、《OpenCV 图像处理实战》</li><li>视频教程：B站搜索“Dev-C++ 教程”</li></ul><h2 id="9-版本控制与协作"><a href="#9-版本控制与协作" class="headerlink" title="9. 版本控制与协作"></a>9. 版本控制与协作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用 Sourcetree、GitKraken 或命令行进行分支与合并管理。</li><li>通过 Pull Request 流程保证代码质量。</li></ul><h2 id="10-单元测试与质量保障"><a href="#10-单元测试与质量保障" class="headerlink" title="10. 单元测试与质量保障"></a>10. 单元测试与质量保障</h2><ul><li>安装 <code>gtest-devpack</code>，链接 <code>-lgtest -lgtest_main</code>。</li><li>示例测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="built_in">TEST</span>(MathTest, Add) &#123; <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span><span class="number">+3</span>,<span class="number">5</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>**argv)</span></span>&#123; testing::<span class="built_in">InitGoogleTest</span>(&amp;argc,argv); <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="11-静态分析与内存检测"><a href="#11-静态分析与内存检测" class="headerlink" title="11. 静态分析与内存检测"></a>11. 静态分析与内存检测</h2><ul><li><code>cppcheck --enable=all --inconclusive --std=c++17 src/</code></li><li>WSL&#x2F;Linux 下使用 <code>valgrind --leak-check=full ./your_executable</code></li></ul><h2 id="12-跨平台构建"><a href="#12-跨平台构建" class="headerlink" title="12. 跨平台构建"></a>12. 跨平台构建</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"><span class="keyword">add_executable</span>(MyApp main.cpp)</span><br></pre></td></tr></table></figure><ul><li>Windows 下 <code>cmake -G &quot;MinGW Makefiles&quot; . &amp;&amp; mingw32-make</code></li><li>WSL 下使用 Linux 编译链</li></ul><h2 id="13-自定义与自动化"><a href="#13-自定义与自动化" class="headerlink" title="13. 自定义与自动化"></a>13. 自定义与自动化</h2><h3 id="13-1-快捷键与宏"><a href="#13-1-快捷键与宏" class="headerlink" title="13.1 快捷键与宏"></a>13.1 快捷键与宏</h3><ul><li><strong>Tools → Editor Options → Keyboard</strong> 自定义快捷键</li><li><strong>Tools → Record Macro</strong> 录制并执行操作</li></ul><h3 id="13-2-构建脚本"><a href="#13-2-构建脚本" class="headerlink" title="13.2 构建脚本"></a>13.2 构建脚本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> /q bin\*</span><br><span class="line">devcpp.exe <span class="literal">-c</span> main.cpp <span class="literal">-o</span> bin\MyApp.exe</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="14-第三方插件与工具"><a href="#14-第三方插件与工具" class="headerlink" title="14. 第三方插件与工具"></a>14. 第三方插件与工具</h2><table><thead><tr><th>DevPak 名称</th><th>功能简介</th></tr></thead><tbody><tr><td>gtkmm-devpack</td><td>GTK+ C++ 图形界面支持</td></tr><tr><td>SDL2-devpack</td><td>跨平台多媒体与游戏开发</td></tr><tr><td>mysql-devpack</td><td>MySQL 数据库接口</td></tr><tr><td>boost-devpack</td><td>智能指针、正则等增强库</td></tr><tr><td>openssl-devpack</td><td>加密与安全通信支持</td></tr></tbody></table><p>可结合 Doxygen、ClangFormat、Bear 提升开发效率。</p><h2 id="15-安全注意事项"><a href="#15-安全注意事项" class="headerlink" title="15. 安全注意事项"></a>15. 安全注意事项</h2><ul><li>开启 <code>-fstack-protector-strong</code></li><li>严格边界检查，防止缓冲区溢出</li><li>发布开启 <code>-Wall -Wextra -Werror</code></li></ul><blockquote><p>本文从基础到高级全面覆盖 Dev-C++ 使用技巧与最佳实践，助您快速上手并精通。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PracticalTools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Dev-C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
