<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>综合声明 (2025-05-20)</title>
      <link href="/posts/%E7%BB%BC%E5%90%88%E5%A3%B0%E6%98%8E-2025-05-20/"/>
      <url>/posts/%E7%BB%BC%E5%90%88%E5%A3%B0%E6%98%8E-2025-05-20/</url>
      
        <content type="html"><![CDATA[<h1 id="综合声明-2025-05-20"><a href="#综合声明-2025-05-20" class="headerlink" title="综合声明 (2025-05-20)"></a>综合声明 (2025-05-20)</h1><p>各位朋友，大家好！感谢你们一直以来对 <strong>Solove</strong> 的关注与支持。经过两个阶段的探索与打磨，博客已于今日完成全面升级，正式进入 <strong>1.0 时代</strong>。在此，我想综合此前 5 月 13 日和 5 月 15 日的声明(已隐藏)，向大家汇报本次更新成果，并分享未来规划。</p><hr><h2 id="一、核心更新亮点"><a href="#一、核心更新亮点" class="headerlink" title="一、核心更新亮点"></a>一、核心更新亮点</h2><ol><li>🆕 <strong>公告卡片 · 支持定位展示</strong>  <ul><li>以卡片形式在页面顶栏展示最新公告，可自动定位读者所在城市或地区。  </li><li>示例：<br><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747745301/22dc8b81-f6f1-4dee-b99d-64a8ea7e904d.png" alt="公告卡片示例"></li></ul></li></ol><ul><li>图：公告卡片示例</li></ul><ol start="2"><li>🔒 <strong>安全跳转页面</strong>  <ul><li>对所有外部链接新增中转页，提示访问风险并提供“取消跳转”按钮，避免误操作。  </li><li>示例：<br><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747745365/f61dde85-b618-4594-9f9b-068f14ffc56b.png" alt="安全跳转示例"></li></ul></li></ol><ul><li>图：安全跳转示例</li></ul><ol start="3"><li><p>🎨 <strong>响应式设计</strong>  </p><ul><li>全站响应式布局，在手机、平板、PC 上均可获得一致的阅读体验。</li></ul></li><li><p>📑 <strong>文章目录与侧边快速导航</strong>  </p><ul><li>自动生成目录树，支持一键跳转，提升长文阅读效率。</li></ul></li><li><p>💻 <strong>代码高亮 + 复制按钮</strong>  </p><ul><li>多语言代码块高亮展示，右上角显示“复制”图标，一键复制示例代码。</li></ul></li></ol><hr><h2 id="二、持续运营与未来展望"><a href="#二、持续运营与未来展望" class="headerlink" title="二、持续运营与未来展望"></a>二、持续运营与未来展望</h2><ul><li><p><strong>内容输出</strong>：  </p><ul><li>博客已完成整体框架及基础功能搭建，进入“稳定运营”阶段。  </li><li>接下来，将以<strong>每周三篇</strong>原创深度技术文章为主，同时保持<strong>不定期</strong>的学习笔记和生活感悟更新。</li></ul></li><li><p><strong>质量升级</strong>：  </p><ul><li>针对早期文章进行重写和完善已经基本完毕，新增完整流程图、注释、典型应用场景。  </li><li>在 GitHub (<a href="https://github.com/1solovedeng">github.com&#x2F;1solovedeng</a>) 同步开源更多代码片段。</li></ul></li><li><p><strong>互动共创</strong>：  </p><ul><li>欢迎大家在评论区留言、提出建议，也可通过邮箱、抖音、B 站互动。  </li><li>如果你对某个技术主题感兴趣，或希望看到专题教程，欢迎随时留言。</li></ul></li></ul><hr><p>✨ <strong>博客网址：</strong> <a href="https://solovedeng.top/">solovedeng.top</a><br>🌟 <strong>同步平台：</strong> 抖音 &#x2F; B 站：solove 等（更多视频教程陆续更新）<br>📬 <strong>联系邮箱：</strong> <a href="mailto:&#115;&#111;&#x6c;&#111;&#x76;&#101;&#x64;&#x65;&#x6e;&#x67;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;">solovedeng@gmail.com</a> </p><p>再次感谢大家一路走来对我的包容与支持！<br>未来我会持续打磨，带来更专业、更有深度的原创内容，期待与你共同成长。  </p><p>— Solove等敬上<br>2025-05-20<br>（520这种日子，愿你始终做自己热爱的事。）</p>]]></content>
      
      
      <categories>
          
          <category> Statement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-3-无重复字符的最长子串（Longest Substring Without Repeating Characters）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Substring-Without-Repeating-Characters%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-20</p></blockquote><h1 id="3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）"><a href="#3-无重复字符的最长子串（Longest-Substring-Without-Repeating-Characters）" class="headerlink" title="3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/"><span style="color:#1E90FF;">3. 无重复字符的最长子串（Longest Substring Without Repeating Characters）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color:#FFA500;">中等</span></h2><p>给定一个字符串 s，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “abcabcbb”</span><br><strong>输出：</strong> <span style="color:#FF4500;">3</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “bbbbb”</span><br><strong>输出：</strong> <span style="color:#FF4500;">1</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">s &#x3D; “pwwkew”</span><br><strong>输出：</strong> <span style="color:#FF4500;">3</span><br><strong>解释：</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3，注意答案必须是子串长度。</p><hr><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h2><ul><li><span style="color:#2E8B57;">0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4</span>  </li><li><span style="color:#2E8B57;">s 由英文字母、数字、符号和空格组成</span></li></ul><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><p><strong>思路：</strong><br>从字符串的每一个起始位置出发，依次向后扩展子串，同时使用一个布尔数组或集合来记录当前子串中出现过的字符，一旦遇到重复字符，则停止扩展，对比记录最长长度。该方法直观易懂，但效率较低。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">seen</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]]) <span class="keyword">break</span>;</span><br><span class="line">                seen[(<span class="type">unsigned</span> <span class="type">char</span>)s[j]] = <span class="literal">true</span>;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n^3)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a><span style="color:#8B0000;">方法二：滑动窗口</span></h2><p><strong>思路：</strong><br>维护一个滑动窗口，用两个指针 l(图中为j)（左边界）和 r(图中为i)（右边界），以及一个哈希数组记录窗口内字符出现次数。当右指针包含的新字符导致重复时，就移动左指针并更新计数，直到窗口中不再有重复字符，同时每次都更新最大窗口长度。</p><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747735661/7f31718c-ff49-42be-a285-5dc8980f57af.png" alt="图1"><br><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747735793/9f054294-e6a4-471d-9e5e-f20f0da07ffb.png" alt="图2"></p><ul><li>以上两图来自力扣题解</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            ++count[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (count[s[r]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --count[s[l]];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="方法三：优化滑动窗口（记录上次出现位置）"><a href="#方法三：优化滑动窗口（记录上次出现位置）" class="headerlink" title="方法三：优化滑动窗口（记录上次出现位置）"></a><span style="color:#8B0000;">方法三：优化滑动窗口（记录上次出现位置）</span></h2><p><strong>思路：</strong><br>使用数组 lastSeen 记录每个字符上次出现的索引，当遍历到字符 s[i] 时，若 lastSeen[s[i]] 在当前窗口内，则直接将左边界 start 移动到 lastSeen[s[i]] + 1，这样无需逐步移动指针，窗口始终保持无重复状态，同时更新最长长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastSeen</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            start = <span class="built_in">max</span>(start, lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] + <span class="number">1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">            lastSeen[(<span class="type">unsigned</span> <span class="type">char</span>)s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：</strong> O(n)  </li><li><strong>空间复杂度：</strong> O(1)</li></ul><hr><h2 id="算法性能与系统原理"><a href="#算法性能与系统原理" class="headerlink" title="算法性能与系统原理"></a>算法性能与系统原理</h2><p>在实际工程中，算法的运行速度与空间占用不仅取决于<strong>算法复杂度</strong>，还深受<strong>底层系统架构</strong>、<strong>缓存局部性</strong>和<strong>内存分配策略</strong>的影响。</p><ol><li><p><strong>缓存命中率（Cache Locality）：</strong>  </p><ul><li><strong>方法一</strong>每次内层循环都重置布尔数组，随机访问计数，导致CPU缓存难以复用，缓存未命中率高，实际运行速度远低于理论复杂度。  </li><li><strong>方法二</strong>与<strong>方法三</strong>使用连续数组存储字符计数或上次出现位置，读取和写入集中在数组局部，具有良好的缓存局部性，缓存命中率高，实际性能优越。</li></ul></li><li><p><strong>分支预测与流水线：</strong>  </p><ul><li><code>while (count[s[r]] &gt; 1)</code>等条件分支会影响CPU流水线。<strong>方法二</strong>中的循环分支较多，而<strong>方法三</strong>通过直接计算新边界减少了条件判断次数，分支更容易预测，流水线停顿更少。</li></ul></li><li><p><strong>内存占用和频繁分配：</strong>  </p><ul><li><strong>方法一</strong>每次迭代都开辟新 <code>vector&lt;bool&gt;</code> 或集合，触发频繁内存分配和释放；  </li><li><strong>方法二</strong>与<strong>方法三</strong>只初始化一次数组，重用内存，减少分配开销。</li></ul></li></ol><hr><h2 id="案例教程：滑动窗口算法实战"><a href="#案例教程：滑动窗口算法实战" class="headerlink" title="案例教程：滑动窗口算法实战"></a>案例教程：滑动窗口算法实战</h2><p>以<strong>方法二</strong>为例，逐步解析运行过程：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入 s = &quot;abca&quot;</span><br><span class="line">初始化: count[&#x27;a&#x27;]=0,count[&#x27;b&#x27;]=0,... l=0, ans=0</span><br><span class="line">r=0: s[0]=&#x27;a&#x27; -&gt; count[&#x27;a&#x27;]++ =&gt; 1, ans=max(0,1)=1</span><br><span class="line">r=1: s[1]=&#x27;b&#x27; -&gt; count[&#x27;b&#x27;]++ =&gt; 1, ans=max(1,2)=2</span><br><span class="line">r=2: s[2]=&#x27;c&#x27; -&gt; count[&#x27;c&#x27;]++ =&gt; 1, ans=max(2,3)=3</span><br><span class="line">r=3: s[3]=&#x27;a&#x27; -&gt; count[&#x27;a&#x27;]++ =&gt; 2 -&gt; 重复，进入 while:</span><br><span class="line">    l=0 -&gt; count[&#x27;a&#x27;]-- =&gt;1, l=1 -&gt; 退出 while，窗口 = [1,3]</span><br><span class="line">更新 ans=max(3,3)=3</span><br><span class="line">最终返回 3</span><br></pre></td></tr></table></figure><hr><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="方法二：滑动窗口-1"><a href="#方法二：滑动窗口-1" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| start l=0, r遍历至n |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | count[s[r]]++ |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | count&gt;1 ?    |--是--&gt; [-- l移动, count[s[l]]--, goto判断 --]</span><br><span class="line">    |             |  否</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 更新 ans     |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | r++ 继续     |</span><br><span class="line">    +--------------+</span><br></pre></td></tr></table></figure><h3 id="方法三：优化滑动窗口"><a href="#方法三：优化滑动窗口" class="headerlink" title="方法三：优化滑动窗口"></a>方法三：优化滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">| 初始化 start=0, lastSeen=-1 |</span><br><span class="line">+----------+--------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 遍历 i from 0|</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 新start = max(start, lastSeen[s[i]]+1) |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | 更新 ans = max(ans, i-start+1)         |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | lastSeen[s[i]] = i                    |</span><br><span class="line">    +------+-------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">    +------v-------+</span><br><span class="line">    | i++ 继续                               |</span><br><span class="line">    +--------------+</span><br></pre></td></tr></table></figure><hr><h2 id="相关建议与扩展"><a href="#相关建议与扩展" class="headerlink" title="相关建议与扩展"></a>相关建议与扩展</h2><ul><li><strong>代码优化：</strong> 在C++中，可以使用 <code>array&lt;int, 256&gt;</code> 替代 <code>vector</code> 以进一步提高性能。  </li><li><strong>Unicode 支持：</strong> 若字符串包含宽字符（如中文），需使用 <code>unordered_map&lt;char32_t,int&gt;</code> 或者对UTF-8字节流逐字节处理。  </li><li><strong>在线测试：</strong> 在多组测试用例下测量执行时间，可使用谷歌<strong>Benchmark</strong>库评估微观性能。</li></ul><hr><h2 id="作者想说的话："><a href="#作者想说的话：" class="headerlink" title="作者想说的话："></a><span style="color:#000080;">作者想说的话：</span></h2><p>这道题是字符串滑动窗口的经典示例，推荐掌握<strong>方法三</strong>作为最佳方案。</p><p>更多字符串变体练习：  </p><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/"><span style="color:#2E8B57;">最长回文子串（Longest Palindromic Substring）</span></a>  </li><li><a href="https://leetcode.cn/problems/minimum-window-substring/"><span style="color:#2E8B57;">最小覆盖子串（Minimum Window Substring）</span></a>  </li><li><a href="https://leetcode.cn/problems/permutation-in-string/"><span style="color:#2E8B57;">字符串的排列（Permutation in String）</span></a>  </li><li><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/"><span style="color:#2E8B57;">最长重复字符替换（Longest Repeating Character Replacement）</span></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-2.两数相加（Add Two Numbers）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add-Two-Numbers%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-20</p></blockquote><h1 id="2-两数相加（Add-Two-Numbers）"><a href="#2-两数相加（Add-Two-Numbers）" class="headerlink" title="2. 两数相加（Add Two Numbers）"></a><a href="https://leetcode.cn/problems/add-two-numbers/"><span style="color:#1E90FF;">2. 两数相加（Add Two Numbers）</span></a></h1><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a><span style="color:#228B22;">中等</span></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。  </p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747730875/d358d38d-28d0-4a61-b425-6a0cc98118a9.png" alt="示例图片"><br><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[7,0,8]</code></span><br><strong>解释：</strong> 342 + 465 &#x3D; 807</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [0]</code>, <code>l2 = [0]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[0]</code></span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;"><code>l1 = [9,9,9,9,9,9,9]</code>, <code>l2 = [9,9,9,9]</code></span><br><strong>输出：</strong> <span style="color:#FF4500;"><code>[8,9,9,9,0,0,0,1]</code></span><br><strong>解释：</strong> 9999999 + 9999 &#x3D; 10009998</p><hr><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h3><ul><li><span style="color:#2E8B57;">每个链表中的节点数在范围 <code>[1, 100]</code> 内</span>  </li><li><span style="color:#2E8B57;">0 &lt;&#x3D; Node.val &lt;&#x3D; 9</span>  </li><li><span style="color:#2E8B57;">题目数据保证列表表示的数字不含前导零</span></li></ul><hr><h2 id="方法一：模拟加法（推荐）"><a href="#方法一：模拟加法（推荐）" class="headerlink" title="方法一：模拟加法（推荐）"></a><span style="color:#8B0000;">方法一：模拟加法（推荐）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(max(m, n))  </li><li><strong>空间复杂度：</strong> O(max(m, n))</li></ul><p><strong>思路：</strong><br>逐位相加并维护进位，利用哑节点简化链表操作。该方法所有运算均发生在寄存器和简单指针运算层面，仅在创建新节点时触发堆分配，性能稳定，推荐首选。</p><hr><h2 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a><span style="color:#8B0000;">方法二：递归实现</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">add</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        node-&gt;next = <span class="built_in">add</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>,</span><br><span class="line">                         l2 ? l2-&gt;next : <span class="literal">nullptr</span>,</span><br><span class="line">                         sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(max(m, n))  </li><li><strong>空间复杂度：</strong> O(max(m, n))（递归栈空间）</li></ul><p><strong>思路：</strong><br>将每一位相加的逻辑递归下沉，递归栈负责维护进位和返回，代码简洁。但受限于系统栈深度，不宜用于特别长的链表。</p><hr><h2 id="方法三：使用栈（适用于正序存储）"><a href="#方法三：使用栈（适用于正序存储）" class="headerlink" title="方法三：使用栈（适用于正序存储）"></a><span style="color:#8B0000;">方法三：使用栈（适用于正序存储）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123; s<span class="number">1.</span><span class="built_in">push</span>(l1-&gt;val); l1 = l1-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123; s<span class="number">2.</span><span class="built_in">push</span>(l2-&gt;val); l2 = l2-&gt;next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>() || carry) &#123;</span><br><span class="line">            <span class="type">int</span> x = s<span class="number">1.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">1.</span><span class="built_in">top</span>(); <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = s<span class="number">2.</span><span class="built_in">empty</span>() ? <span class="number">0</span> : s<span class="number">2.</span><span class="built_in">top</span>(); <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            node-&gt;next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> O(m + n)  </li><li><strong>空间复杂度：</strong> O(m + n)</li></ul><p><strong>思路：</strong><br>先反转链表至正序，利用显式栈缓存各位数字，再完成加法后恢复逆序。适合链表已正序存储或需保留原链表不变的场景。</p><hr><h2 id="算法底层原理与性能优化"><a href="#算法底层原理与性能优化" class="headerlink" title="算法底层原理与性能优化"></a><span style="color:#2E8B57;">算法底层原理与性能优化</span></h2><p><strong>寄存器与内存分配</strong>  </p><ul><li>简单整数加法与指针操作均在 CPU 寄存器中完成，流水线友好。  </li><li>堆上对象（ListNode）频繁分配会产生系统调用开销，可通过对象池复用减少成本。</li></ul><p><strong>递归栈 vs 显式栈</strong>  </p><ul><li>递归受限于系统栈深度且每层额外保存返回地址及参数；显式栈分配更可控且缓存局部性更好。</li></ul><p><strong>缓存局部性与对象池</strong>  </p><ul><li>链表节点散落在堆中，容易发生缓存未命中；使用对象池可集中分配、提高缓存命中率。</li></ul><p><strong>并行化思考</strong>  </p><ul><li>对于超长向量加法，可考虑 SIMD；链表场景下收益有限，通常不建议。</li></ul><hr><h2 id="模拟加法（迭代）流程图"><a href="#模拟加法（迭代）流程图" class="headerlink" title="模拟加法（迭代）流程图"></a><span style="color:#DAA520;">模拟加法（迭代）流程图</span></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|    开始 addTwoNumbers     |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 初始化 dummy, p, carry=0  |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| l1/l2 任一不空或 carry=1? - No -&gt; 返回 dummy.next</span><br><span class="line">+------------+-+------------+</span><br><span class="line">             |</span><br><span class="line">            Yes</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| x = l1?l1-&gt;val:0, y = ...  |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| sum = x+y+carry           |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| carry = sum/10            |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 新节点 val=sum%10         |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| p-&gt;next=node; p=node      |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">+------------+--------------+</span><br><span class="line">| l1?l1=l1-&gt;next, l2同理    |</span><br><span class="line">+------------+--------------+</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">           重复循环</span><br></pre></td></tr></table></figure><hr><h2 id="对象池优化示例（伪码）"><a href="#对象池优化示例（伪码）" class="headerlink" title="对象池优化示例（伪码）"></a><span style="color:#4682B4;">对象池优化示例（伪码）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNodePool</span> &#123;</span><br><span class="line">    std::vector&lt;ListNode*&gt; pool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">alloc</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pool.<span class="built_in">back</span>(); pool.<span class="built_in">pop_back</span>();</span><br><span class="line">            node-&gt;val = v; node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListNode</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        pool.<span class="built_in">push_back</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">fastAdd</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNodePool pool;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *p </span>= &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">auto</span> node = pool.<span class="built_in">alloc</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p-&gt;next = node; p = node;</span><br><span class="line">        <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>作者想说的话：</em><br>“两数相加”作为链表模拟经典题，不仅要掌握三种常见解法，更需理解底层运行原理与优化思路，才能在面试和工程实践中游刃有余。</p><p>推荐拓展练习：<a href="https://leetcode.cn/problems/add-two-numbers-ii/">力扣 445. 两数相加 II</a>（正序版本）。</p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目推荐-SDL太空战机射击游戏(SDLShooter)</title>
      <link href="/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/"/>
      <url>/posts/%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90-SDL%E5%A4%AA%E7%A9%BA%E6%88%98%E6%9C%BA%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F-SDLShooter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-19</p></blockquote><h1 align="center" style="color:#1E90FF;">🚀 推荐项目：SDL 太空战机射击游戏</h1><h2 id="🧭-项目简介"><a href="#🧭-项目简介" class="headerlink" title="🧭 项目简介"></a>🧭 项目简介</h2><ul><li><strong>项目名称</strong>：<strong>SDLShooter</strong>（太空战机射击游戏）  </li><li><strong>教程主页</strong>：👉 <a href="https://cppgamedev.top/courses/sdl-space-shooter">https://cppgamedev.top/courses/sdl-space-shooter</a>  </li><li><strong>源项目仓库</strong>：🔗 <a href="https://github.com/WispSnow/SDLShooter">github.com&#x2F;WispSnow&#x2F;SDLShooter</a>  </li><li><strong>我的个性化版本(持续学习并更新中)</strong>：✨ <a href="https://github.com/1solovedeng/SDLShooter">github.com&#x2F;1solovedeng&#x2F;SDLShooter</a>  </li><li><strong>开源协议</strong>：🆓 <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0-1.0（公有领域，无需署名）</a></li></ul><hr><h2 id="🧑‍💻-为什么推荐这个项目给初学者？"><a href="#🧑‍💻-为什么推荐这个项目给初学者？" class="headerlink" title="🧑‍💻 为什么推荐这个项目给初学者？"></a>🧑‍💻 <span style="color:#FF6600;"><strong>为什么推荐这个项目给初学者？</strong></span></h2><ol><li>🛠️ <span style="color:#00BFFF;"><strong>跨平台、零门槛</strong></span>：基于 SDL2&#x2F;SDL3，支持 Windows &#x2F; Linux &#x2F; macOS，全平台开发无压力。  </li><li>🧩 <span style="color:#32CD32;"><strong>模块化教程</strong></span>：每个章节配有文字+视频教学，对应源码分支一一匹配，方便跟进。  </li><li>🔍 <span style="color:#FF1493;"><strong>实战 + 原理结合</strong></span>：涵盖图形渲染、输入处理、碰撞检测、资源加载等游戏开发核心。  </li><li>📦 <span style="color:#FFA500;"><strong>内置丰富素材</strong></span>：内含音乐、音效、精灵图、爆炸特效、字体，无需再东找西找。  </li><li>🌱 <span style="color:#8A2BE2;"><strong>超自由授权</strong></span>：CC0 许可可商用可二创，想怎么玩都行！</li></ol><hr><h2 id="🌟-项目亮点展示"><a href="#🌟-项目亮点展示" class="headerlink" title="🌟 项目亮点展示"></a>🌟 <span style="color:#DC143C;"><strong>项目亮点展示</strong></span></h2><ul><li>🎮 <span style="color:#FF4500;"><strong>完整功能</strong></span>：主菜单、敌机 AI、爆炸特效、子弹发射、BGM 等典型系统一应俱全。  </li><li>🖼️ <span style="color:#1E90FF;"><strong>高质量素材包整合</strong></span>：以下资源全部 CC0 免费可用：  <ul><li>飞机素材：<a href="https://anim86.itch.io/space-shoter-starter-pack">anim86.itch.io</a>  </li><li>UI 血条：<a href="https://doshrosity.itch.io/32x32-health-ui">doshrosity.itch.io</a>  </li><li>音效包：<a href="https://enprimer.itch.io/spaceship-sound-effects-pack">enprimer.itch.io</a>  </li><li>音乐包：<a href="https://leohpaz.itch.io/space-music-pack">leohpaz.itch.io</a>  </li><li>像素字体：<a href="https://timothyqiu.itch.io/vonwaon-bitmap">timothyqiu.itch.io</a>  </li><li>爆炸特效：<a href="https://ansimuz.itch.io/explosion-animations-pack">ansimuz.itch.io</a></li></ul></li><li>🧠 <span style="color:#20B2AA;"><strong>面向学习设计</strong></span>：每章节分支 <code>chapter-x</code> 可一键跳转当前进度，边学边练最舒适。  </li><li>💡 <span style="color:#FF69B4;"><strong>高度可扩展性</strong></span>：源码清晰，便于添加关卡系统、武器升级、多玩家或联网功能。</li></ul><hr><h2 id="🛠️-环境配置指南"><a href="#🛠️-环境配置指南" class="headerlink" title="🛠️ 环境配置指南"></a>🛠️ 环境配置指南</h2><h3 id="🔵-Linux（Ubuntu）"><a href="#🔵-Linux（Ubuntu）" class="headerlink" title="🔵 Linux（Ubuntu）"></a>🔵 Linux（Ubuntu）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install cmake libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev</span><br></pre></td></tr></table></figure><h3 id="🍎-macOS（基于-Homebrew）"><a href="#🍎-macOS（基于-Homebrew）" class="headerlink" title="🍎 macOS（基于 Homebrew）"></a>🍎 macOS（基于 Homebrew）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake sdl2 sdl2_image sdl2_mixer sdl2_ttf</span><br></pre></td></tr></table></figure><h3 id="🪟-Windows（推荐使用-Visual-Studio-或-VSCode）"><a href="#🪟-Windows（推荐使用-Visual-Studio-或-VSCode）" class="headerlink" title="🪟 Windows（推荐使用 Visual Studio 或 VSCode）"></a>🪟 Windows（推荐使用 Visual Studio 或 VSCode）</h3><ol><li>安装 <strong>Visual Studio 生成工具</strong>（或使用 VS2022）。  </li><li>下载 SDL2、SDL2_image、SDL2_mixer、SDL2_ttf 的 MSVC 版本。  </li><li>将 SDL <code>主文件夹路径</code> 与 <code>lib\x64</code> 添加到系统 PATH。  </li><li>使用 CMake 构建项目即可。</li></ol><hr><h2 id="🚀-快速开始（命令行方式）"><a href="#🚀-快速开始（命令行方式）" class="headerlink" title="🚀 快速开始（命令行方式）"></a>🚀 快速开始（命令行方式）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/WispSnow/SDLShooter.git</span><br><span class="line"><span class="built_in">cd</span> SDLShooter</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./SDLShooter</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>提示</strong>：也可以用 Visual Studio、CLion、VSCode 等 IDE 直接打开项目。</p></blockquote><hr><h2 id="🔧-我的个性版本（持续学习并更新中）"><a href="#🔧-我的个性版本（持续学习并更新中）" class="headerlink" title="🔧 我的个性版本（持续学习并更新中）"></a>🔧 我的个性版本（持续学习并更新中）</h2><p>📌 欢迎查看我的个性化实现和改进版：<a href="https://github.com/1solovedeng/SDLShooter">https://github.com/1solovedeng/SDLShooter</a></p><hr><h2 id="🎯-适合谁？"><a href="#🎯-适合谁？" class="headerlink" title="🎯 适合谁？"></a>🎯 <span style="color:#00CED1;"><strong>适合谁？</strong></span></h2><ul><li>📚 C++ 初学者，希望快速建立完整项目经验  </li><li>🎮 对游戏开发感兴趣，想了解从零构建一个 2D 游戏的全过程  </li><li>💡 想基于 SDL 引擎进行拓展开发，如 AI、粒子、物理、地图编辑器等</li></ul><hr><h2 id="🏁-总结"><a href="#🏁-总结" class="headerlink" title="🏁 总结"></a>🏁 总结</h2><p>🎉 <strong>SDLShooter</strong> 是一个集实战、学习、素材、授权于一体的超强新手项目。<br>🎯 如果你正在寻找一个能立刻投入实践、同时能打通 SDL 知识体系的项目，它就是你的最佳选择！<br>🛠️ 动手开发，<span style="color:#32CD32;"><strong>从这款射击游戏开始你的 C++ 游戏开发之路！</strong></span></p><hr><h2 id="🔍-算法原理与优化"><a href="#🔍-算法原理与优化" class="headerlink" title="🔍 算法原理与优化"></a>🔍 算法原理与优化</h2><p>在一个 2D 射击游戏中，核心算法直接影响运行速度和内存使用。下面我们将针对三种关键算法：游戏主循环（Game Loop）、碰撞检测（AABB 算法）、资源管理（对象池算法），分别说明思路、流程图、原理注释，并从计算机原理角度分析其时间复杂度与空间复杂度。</p><h3 id="1-游戏主循环（Game-Loop-固定时间步长算法）"><a href="#1-游戏主循环（Game-Loop-固定时间步长算法）" class="headerlink" title="1. 游戏主循环（Game Loop 固定时间步长算法）"></a>1. 游戏主循环（Game Loop 固定时间步长算法）</h3><p><strong>思路</strong>：  </p><ul><li>保持稳定的游戏帧率，避免不同硬件导致的速度不一致。  </li><li>将更新步骤与渲染步骤分离，使用固定时间步长（如 16ms&#x2F;帧），在一帧内可多次更新或跳帧渲染。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> MS_PER_UPDATE = <span class="number">16.6667</span>; <span class="comment">// 60 FPS</span></span><br><span class="line"><span class="type">double</span> previous = <span class="built_in">SDL_GetTicks</span>();</span><br><span class="line"><span class="type">double</span> lag = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="type">double</span> current = <span class="built_in">SDL_GetTicks</span>();</span><br><span class="line">    <span class="type">double</span> elapsed = current - previous;</span><br><span class="line">    previous = current;</span><br><span class="line">    lag += elapsed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processInput</span>(); <span class="comment">// 处理玩家输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lag &gt;= MS_PER_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">update</span>();    <span class="comment">// 更新游戏逻辑</span></span><br><span class="line">        lag -= MS_PER_UPDATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(interpolation = lag / MS_PER_UPDATE); <span class="comment">// 渲染并插值动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ 开始主循环 │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────────┐</span><br><span class="line">│ 获取当前时间  │</span><br><span class="line">│ current = t   │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌────────────────────────┐</span><br><span class="line">│ 计算 elapsed =         │</span><br><span class="line">│ current - previous     │</span><br><span class="line">└─────┬─────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────────┐</span><br><span class="line">│ lag += elapsed │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│ 处理玩家输入 │</span><br><span class="line">└─────┬────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│ while (lag &gt;= MS_PER_UPDATE) &#123;     │</span><br><span class="line">│     update();                      │</span><br><span class="line">│     lag -= MS_PER_UPDATE;          │</span><br><span class="line">│ &#125;                                   │</span><br><span class="line">└─────┬──────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│ render(interpolation)    │</span><br><span class="line">└─────┬───────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│ previous = current       │</span><br><span class="line">└─────┬───────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───────────┐</span><br><span class="line">│ 回到第1步 │</span><br><span class="line">└───────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>使用 SDL_GetTicks() 获取毫秒计时，依赖硬件计时器。  </li><li>固定时间步长避免物理计算的抖动与不一致。  </li><li>插值渲染（interpolation）减少渲染抖动。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／帧，每帧固定更新次数，最坏情况下渲染略有抖动。  </li><li>空间复杂度：O(1)，常量内存使用。  </li><li><strong>计算机原理</strong>：减少分支跳转，提高 CPU 分支预测命中率；固定循环结构也有助于缓存友好，从而提高管线吞吐。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658297/41480e08-883a-470a-9eb9-a42b4d81053b.png" alt="主循环示例"></p><ul><li>图：主循环示例</li></ul><hr><h3 id="2-碰撞检测（轴对齐包围盒-AABB-算法）"><a href="#2-碰撞检测（轴对齐包围盒-AABB-算法）" class="headerlink" title="2. 碰撞检测（轴对齐包围盒 AABB 算法）"></a>2. 碰撞检测（轴对齐包围盒 AABB 算法）</h3><p><strong>思路</strong>：  </p><ul><li>为每个精灵创建一个矩形边界；  </li><li>通过比较矩形的 x 和 y 范围来判断是否相交。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AABB</span><span class="params">(<span class="type">const</span> Rect&amp; a, <span class="type">const</span> Rect&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x &lt; b.x + b.w &amp;&amp;</span><br><span class="line">            a.x + a.w &gt; b.x &amp;&amp;</span><br><span class="line">            a.y &lt; b.y + b.h &amp;&amp;</span><br><span class="line">            a.y + a.h &gt; b.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图（txt 格式）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│ 取矩形 a 和 b 的   │</span><br><span class="line">│ x, y, w, h         │</span><br><span class="line">└─────────┬──────────┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.x &lt; b.x + b.w ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.x + a.w &gt; b.x ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.y &lt; b.y + b.h ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│ 判断 a.y + a.h &gt; b.y ?    │</span><br><span class="line">└─────────┬─────────────────┘</span><br><span class="line">          │ Yes/No</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────────────────────────┐</span><br><span class="line">│ 若上述均为真，则 “碰撞”             │</span><br><span class="line">└─────────┬──────────────────────────┘</span><br><span class="line">          │</span><br><span class="line">         否则</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────────────────────────┐</span><br><span class="line">│ 否则 “无碰撞”                       │</span><br><span class="line">└──────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>通过连续的比较操作，判断两个区间是否重叠。  </li><li>矩形检测分支较少，CPU 分支预测效果好；  </li><li>内存占用小，仅存储四个浮点数或整数。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／两精灵对检测；  </li><li>若检测所有 N 个敌机与子弹对，则最坏为 O(N²)；  </li><li>空间复杂度：O(N)，存储 N 个包围盒。  </li><li><strong>计算机原理</strong>：数据存连续存储，可利用缓存行；简单算术与逻辑运算很少访存；分支较少可极大提升流水线利用率。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658477/ebab4866-7af8-4e6c-bb80-4c23b2686f17.png" alt="AABB 碰撞示意图"></p><ul><li>图：AABB碰撞示意图</li></ul><hr><h3 id="3-资源管理（对象池-Object-Pool-算法）"><a href="#3-资源管理（对象池-Object-Pool-算法）" class="headerlink" title="3. 资源管理（对象池 Object Pool 算法）"></a>3. 资源管理（对象池 Object Pool 算法）</h3><p><strong>思路</strong>：  </p><ul><li>预先分配固定大小的对象池，避免频繁 new&#x2F;delete 或 malloc&#x2F;free 导致的内存碎片化和性能波动；  </li><li>通过栈或链表管理空闲对象，获取和归还操作均为 O(1)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 可扩展或抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        T* obj = freeList.<span class="built_in">back</span>();</span><br><span class="line">        freeList.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(T* obj)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push_back</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T*&gt; freeList;</span><br><span class="line">    std::unique_ptr&lt;T[]&gt; pool; <span class="comment">// 实际存储</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>流程图（txt 格式）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ 初始化：分配连续内存 pool，所有对象入栈 freeList │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ acquire():                                 │</span><br><span class="line">│   从 freeList 弹出一个对象                  │</span><br><span class="line">│   返回给调用者                              │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ release(obj):                              │</span><br><span class="line">│   将 obj 推入 freeList                      │</span><br><span class="line">└───────────────────────────┬─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│ 结束                                     │</span><br><span class="line">└─────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><ul><li><p><strong>原理注释</strong>：  </p><ul><li>预分配的连续内存块减少碎片；  </li><li>std::vector 管理的 freeList 保证快速索引；  </li><li>避免动态分配带来的系统调用开销。</li></ul></li><li><p><strong>复杂度分析</strong>：  </p><ul><li>时间复杂度：O(1)／次；  </li><li>空间复杂度：O(N)，预分配 N 个对象；  </li><li><strong>计算机原理</strong>：连续内存利于缓存；减少系统调用和堆管理锁竞争；极大提高运行稳定性。</li></ul></li></ul><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747658746/cbfa370a-7f8a-4708-83c7-e28b5c0201be.png" alt="对象池示意图"></p><hr><h2 id="📚-深度学习教程推荐"><a href="#📚-深度学习教程推荐" class="headerlink" title="📚 深度学习教程推荐"></a>📚 深度学习教程推荐</h2><ul><li><strong>Game Loop 详解</strong>：  <ul><li>《Game Programming Patterns》中的 <a href="https://gameprogrammingpatterns.com/game-loop.html">Game Loop 一章</a></li></ul></li><li><strong>碰撞检测优化</strong>：  <ul><li>AABB、Sweep and Prune 等多种方法比较：<a href="https://gamedevelopment.tutsplus.com/tutorials">博客链接</a></li></ul></li><li><strong>对象池最佳实践</strong>：  <ul><li>《C++ Concurrency in Action》中资源管理章节</li></ul></li></ul><p>以上三种算法是任何 2D 游戏的基础，了解其原理并掌握优化策略，对性能提升与稳定性保障至关重要。</p><hr><h2 align="center" style="color:#FF8C00;">🌌 Happy Coding & Enjoy Shooting! 🌌</h2>]]></content>
      
      
      <categories>
          
          <category> ProjectPicks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDL </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-1.两数之和（Two Sum）</title>
      <link href="/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/"/>
      <url>/posts/%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Two-Sum%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于2025-5-18</p></blockquote><h1 id="1-两数之和（Two-Sum）"><a href="#1-两数之和（Two-Sum）" class="headerlink" title="1. 两数之和（Two Sum）"></a><a href="https://leetcode.cn/problems/two-sum/"><span style="color:#1E90FF;">1. 两数之和（Two Sum）</span></a></h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a><span style="color:#228B22;">简单</span></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p><hr><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><span style="color:#800080;">示例 1：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><strong>输出：</strong> <span style="color:#FF4500;">[0,1]</span><br><strong>解释：</strong> 因为 <span style="color:#DAA520;">nums[0] + nums[1] &#x3D;&#x3D; 9</span>，返回 <span style="color:#DAA520;">[0, 1]</span>。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><span style="color:#800080;">示例 2：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [3,2,4], target &#x3D; 6</span><br><strong>输出：</strong> <span style="color:#FF4500;">[1,2]</span></p><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><span style="color:#800080;">示例 3：</span></h3><p><strong>输入：</strong> <span style="color:#FF4500;">nums &#x3D; [3,3], target &#x3D; 6</span><br><strong>输出：</strong> <span style="color:#FF4500;">[0,1]</span></p><hr><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><span style="color:#FF8C00;">提示：</span></h3><ul><li><span style="color:#2E8B57;">2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</span>  </li><li><span style="color:#2E8B57;">-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</span>  </li><li><span style="color:#2E8B57;">-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</span>  </li><li><span style="color:#2E8B57;">只会存在一个有效答案</span></li></ul><hr><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a><span style="color:#FF8C00;">进阶：</span></h3><p>你可以想出一个时间复杂度小于 <span style="color:#2F4F4F;">O(n^2)</span> 的算法吗？</p><hr><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a><span style="color:#8B0000;">方法一：暴力枚举</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">47ms</span>，击败 <span style="color:#8B0000;">28.79%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">13.80MB</span>，击败 <span style="color:#8B0000;">83.42%</span></li></ul><p><strong>思路：</strong><br>嵌套两个循环，枚举数组中每一对 (i, j)，检查 <span style="color:#DAA520;">nums[i] + nums[j] &#x3D;&#x3D; target</span> 时立即返回下标。不使用额外空间，直观易实现，但在 n 较大时性能迅速下降。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ Start     │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i=0, j=1</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Check sum │</span><br><span class="line">│ nums[i]+  │</span><br><span class="line">│ nums[j]   │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ == target?</span><br><span class="line"> ┌────▼────┐      ┌───────────┐</span><br><span class="line"> │ Yes     │────▶│ Return    │</span><br><span class="line"> │         │      │ &#123;i, j&#125;    │</span><br><span class="line"> └────▲────┘      └───────────┘</span><br><span class="line">      │ No</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ j++ or    │</span><br><span class="line">│ i++, reset│</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ Continue</span><br><span class="line">      ▼</span><br><span class="line">    End loop</span><br></pre></td></tr></table></figure><hr><h2 id="方法二：二次遍历哈希表"><a href="#方法二：二次遍历哈希表" class="headerlink" title="方法二：二次遍历哈希表"></a><span style="color:#8B0000;">方法二：二次遍历哈希表</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 第一次遍历：填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lookup[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次遍历：找补数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> c = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">7ms</span>，击败 <span style="color:#8B0000;">43.89%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">15.74MB</span>，击败 <span style="color:#8B0000;">5.38%</span></li></ul><p><strong>思路：</strong><br>利用哈希表在 O(1) 平均时间内完成查找。第一次遍历将元素值映射到下标，第二次遍历寻找补数并验证。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│ Start     │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i=0</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Fill map  │</span><br><span class="line">│ lookup[   │</span><br><span class="line">│ nums[i]]=i│</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ i&lt;n?</span><br><span class="line"> ┌────▼────┐      ┌────────┐</span><br><span class="line"> │ Yes     │────▶│Continue│</span><br><span class="line"> └────▲────┘      └────────┘</span><br><span class="line">      │ No</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ j=0       │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │</span><br><span class="line">┌─────▼─────┐</span><br><span class="line">│ Find c    │</span><br><span class="line">│ c=target- │</span><br><span class="line">│ nums[j]   │</span><br><span class="line">└─────┬─────┘</span><br><span class="line">      │ found?</span><br><span class="line">┌─────▼─────┐      ┌────────┐</span><br><span class="line">│ Yes       │────▶│ Return │</span><br><span class="line">│           │      │ &#123;j,it &#125;│</span><br><span class="line">└─────┬─────┘      └────────┘</span><br><span class="line">      │ No</span><br><span class="line">      ▼</span><br><span class="line">    j++, loop</span><br></pre></td></tr></table></figure><hr><h2 id="方法三：一次遍历哈希表（相对最优解）"><a href="#方法三：一次遍历哈希表（相对最优解）" class="headerlink" title="方法三：一次遍历哈希表（相对最优解）"></a><span style="color:#8B0000;">方法三：一次遍历哈希表（相对最优解）</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lookup;              <span class="comment">// 准备一个空的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 遍历每个元素</span></span><br><span class="line">            <span class="type">int</span> complement = target - nums[i];       <span class="comment">// 计算补数</span></span><br><span class="line">            <span class="keyword">auto</span> it = lookup.<span class="built_in">find</span>(complement);       <span class="comment">// 在哈希表中查找补数</span></span><br><span class="line">            <span class="keyword">if</span> (it != lookup.<span class="built_in">end</span>()) &#123;               <span class="comment">// 若找到了</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;              <span class="comment">// 立即返回“补数的下标 + 当前下标”</span></span><br><span class="line">            &#125;</span><br><span class="line">            lookup[nums[i]] = i;                     <span class="comment">// 否则，将当前元素插入哈希表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>执行用时：</strong> <span style="color:#8B0000;">0ms</span>，击败 <span style="color:#8B0000;">100.00%</span>  </li><li><strong>内存消耗：</strong> <span style="color:#8B0000;">14.55MB</span>，击败 <span style="color:#8B0000;">45.96%</span></li></ul><p><strong>思路：</strong><br>在同一次遍历中完成查找与插入操作，边遍历边搜索，降低了常数开销，是最优实践。</p><p><strong>流程图：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌────────────┐</span><br><span class="line">│ Start      │</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ i=0</span><br><span class="line">┌──────▼─────┐</span><br><span class="line">│ Compute    │</span><br><span class="line">│ complement │</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ lookup.find?</span><br><span class="line">┌──────▼─────┐      ┌──────────┐</span><br><span class="line">│ Found?     │────▶│ Return   │</span><br><span class="line">│ it!=end    │      │ &#123;pos,i&#125;  │</span><br><span class="line">└──────┬─────┘      └──────────┘</span><br><span class="line">       │ No</span><br><span class="line">┌──────▼─────┐</span><br><span class="line">│ Insert num │</span><br><span class="line">│ lookup[val]│</span><br><span class="line">└──────┬─────┘</span><br><span class="line">       │ Continue</span><br><span class="line">       ▼</span><br><span class="line">     End loop</span><br></pre></td></tr></table></figure><hr><h2 id="算法原理与性能分析"><a href="#算法原理与性能分析" class="headerlink" title="算法原理与性能分析"></a>算法原理与性能分析</h2><ol><li><p><strong>计算机层面运行原理</strong>  </p><ul><li><strong>CPU 指令流水线</strong>：在暴力枚举中，分支预测失误成本高，频繁分支跳转导致流水线清空，降低执行效率。哈希查找中分支少，流水线利用率更高。  </li><li><strong>缓存（Cache）命中</strong>：暴力枚举随机访问数组元素，缓存命中率较低；哈希表操作也有随机访问，但现代 CPU L1&#x2F;L2 缓存可加速哈希桶的访问。  </li><li><strong>内存分配与扩展</strong>：哈希表在增长时需要重新分配和再哈希，开销为 O(n)，但摊销到每次插入时均摊为 O(1)。</li></ul></li><li><p><strong>时间复杂度分析</strong>  </p><ul><li>暴力枚举：O(n²)，随着 n 增大，运算量急剧上升。  </li><li>二次遍历哈希：O(n) + O(n) &#x3D; O(n)，额外遍历构建和查找。  </li><li>一次遍历哈希：O(n) 平均，最坏 O(n²)（所有元素哈希冲突时）。</li></ul></li><li><p><strong>空间复杂度分析</strong>  </p><ul><li>暴力枚举：O(1)，无额外存储。  </li><li>哈希表方法：O(n)，需存储 n 个键值对。  </li><li>空间换时间策略：在内存充足时，优先考虑哈希方法。</li></ul></li><li><p><strong>实践建议</strong>  </p><ul><li>对于小规模数组（n &lt; 1000），暴力枚举也能在毫秒级完成。  </li><li>对于大规模数据，推荐一次遍历哈希，保证线性性能。  </li><li>若内存敏感，可考虑空间占用更小的排序加双指针方案，但不适用于无序数组的索引返回。</li></ul></li></ol><hr><h2 id="教程与扩展"><a href="#教程与扩展" class="headerlink" title="教程与扩展"></a>教程与扩展</h2><ol><li><p><strong>详细步骤</strong>  </p><ul><li>理解题意：需要返回下标，对数组进行两两组合或查找补数。  </li><li>选择合适的数据结构：哈希表对于查找补数是最合适的。  </li><li>编码实现：注意边界条件与哈希冲突。  </li><li>测试用例：考虑正负数、重复元素、目标值为 0 等。</li></ul></li><li><p><strong>可视化教程</strong>  </p><h2 id="线性探测插入流程详解"><a href="#线性探测插入流程详解" class="headerlink" title="线性探测插入流程详解"></a>线性探测插入流程详解</h2></li></ol><p><img src="https://res.cloudinary.com/ddacx9czn/image/upload/v1747581726/b79aa1fde303b05cdba669f5eb6b60ae_tydwtx.gif"></p><h2 id="哈希表插入示例"><a href="#哈希表插入示例" class="headerlink" title="哈希表插入示例"></a>哈希表插入示例</h2><p>① <strong>插入第一个元素</strong>  </p><ul><li>将键值对 <code>(7, &quot;seven&quot;)</code> 准备插入哈希表。  </li><li>通过哈希函数计算，得到目标下标为 <code>0</code>。  </li><li>检查哈希表索引 <code>0</code> 处，当前为空槽，所以直接在此位置存放 <code>(7, &quot;seven&quot;)</code>。</li></ul><p>② <strong>插入第二个元素</strong>  </p><ul><li>将键值对 <code>(14, &quot;fourteen&quot;)</code> 准备插入哈希表。  </li><li>经过同样的哈希映射，也得到下标 <code>0</code>。  </li><li>发现位置 <code>0</code> 已被占用，需要寻找下一个可用槽。</li></ul><p>③ <strong>线性探测寻址</strong>  </p><ul><li>从冲突下标 <code>0</code> 开始，依次往后探查：  <ol><li>检查下标 <code>1</code>，若为空则将 <code>(14, &quot;fourteen&quot;)</code> 存入；  </li><li>若下标 <code>1</code> 也已占用，则继续检查下标 <code>2</code>、<code>3</code>……</li></ol></li><li>直到遇到第一个空槽，将该键值对存储于此。</li></ul><hr><p><strong>说明：</strong>  </p><ul><li>本示例采用“线性探测”（Linear Probing）法来处理哈希冲突；  </li><li>如果探测到数组末尾仍未找到空槽，可认为哈希表已满，或采取环绕回到数组开头的方式继续探测。</li></ul><hr><p><strong>实践练习</strong>  </p><ul><li>变体题目：<a href="https://leetcode.cn/problems/3sum/description/">三数之和 Three Sum</a>、和<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">为 K 的子数组 Subarray Sum</a> 等。  </li><li>针对排序数组：使用双指针法。  </li><li>考虑多目标时的通用解决方案。</li></ul><hr><p><em>作者想说的话：</em><br>“两数之和（Two Sum）” 是经典入门题，这三种解法体现了解题思路的演进。深入理解算法底层原理，有助于在面试和工程实践中快速做出最佳选择。  </p>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具-Dev-C++</title>
      <link href="/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/"/>
      <url>/posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-Dev-C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最后编辑于 2025-5-18</p></blockquote><h1 id="🛠️-推荐工具：Dev-C"><a href="#🛠️-推荐工具：Dev-C" class="headerlink" title="🛠️ 推荐工具：Dev-C++"></a>🛠️ 推荐工具：Dev-C++</h1><p><strong>Dev-C++</strong> 是一款轻量级、免费开源的 C&#x2F;C++ 集成开发环境（IDE），内置 GCC 编译器，适用于 Windows 系统。其界面简洁、操作直观，尤其适合 C&#x2F;C++ 初学者使用。</p><h2 id="✅-主要特点"><a href="#✅-主要特点" class="headerlink" title="✅ 主要特点"></a>✅ 主要特点</h2><ul><li><strong>语法高亮与代码补全</strong>：支持语法高亮显示和自动代码补全，减少编辑错误，提高编码效率。</li><li><strong>多语言支持</strong>：提供简体中文、繁体中文、英语等多种语言界面，方便不同用户使用。</li><li><strong>内置调试功能</strong>：集成调试器，支持断点设置、变量监视等基本调试操作。</li><li><strong>适合初学者</strong>：操作简便，学习成本低，是学习 C&#x2F;C++ 编程的理想工具。</li><li><strong>集成多种工具</strong>：集合了 MinGW 中的 GCC 编译器、GDB 调试器和 AStyle 格式整理器等自由软件。</li></ul><h2 id="📥-下载地址"><a href="#📥-下载地址" class="headerlink" title="📥 下载地址"></a>📥 下载地址</h2><ul><li>阿里云盘： <a href="https://www.alipan.com/s/JDbA6mR8iVm">点击下载</a></li><li>百度网盘： <a href="https://pan.baidu.com/s/1S4FZFabzbIL2nK_bfe6MNw?pwd=nura">点击下载</a>  <blockquote><p>提取码：<code>nura</code></p></blockquote></li><li>夸克网盘： <a href="https://pan.quark.cn/s/5176261faeae">点击下载</a></li></ul><blockquote><p>⚠️ 如果链接失效，请在评论区留言，我们会及时更新。感谢您的支持与指正！</p></blockquote><h2 id="📚-安装与使用教程"><a href="#📚-安装与使用教程" class="headerlink" title="📚 安装与使用教程"></a>📚 安装与使用教程</h2><ul><li><a href="https://www.dotcpp.com/course/338">Dev-C++ 下载与安装图文教程</a></li><li><a href="https://blog.csdn.net/bigzql/article/details/109349382">Dev-C++ 安装及使用方法教程</a></li></ul><hr><h2 id="⚠️-声明"><a href="#⚠️-声明" class="headerlink" title="⚠️ 声明"></a>⚠️ <strong>声明</strong></h2><p><strong>Dev-C++</strong> 因多年未获持续更新，其核心工具链和功能已显过时，不再适合中大型或需现代 C&#x2F;C++ 特性（如 C++17&#x2F;20、模块化构建、内置包管理等）的项目开发。  </p><blockquote><ul><li><strong>官方原始版</strong>（Bloodshed Software）自 2005 年 2 月 22 日起即停止活跃维护，后续开发主要停滞不前，存在大量已知缺陷难以修复。</li><li><strong>Embarcadero 维护的最新版</strong>（最新 6.3 版本）最后发布于 2021 年 1 月 30 日，且最近一次更新记录为 2021 年 5 月 19 日，距今已逾四年。</li></ul></blockquote><p><strong>建议</strong>  </p><blockquote><ul><li><strong>仅限入门学习</strong>：Dev-C++ 界面简洁、操作直观，适合作为 C&#x2F;C++ 新手的入门练习环境。  </li><li><strong>深入研究</strong>：文中详述的环境配置、项目管理与调试技巧，建议仅用于学习参考及历史研究，若进行实际开发，请优先选择更现代的 IDE，如 <strong>Visual Studio</strong>, <strong>CLion</strong>, <strong>Code::Blocks</strong>, 或基于 <strong>VS Code</strong> 的开发环境。</li></ul></blockquote><hr><h2 id="⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点："><a href="#⚠️在-Dev-C-中出现中文“锟斤拷”或乱码，主要源自以下几点：" class="headerlink" title="⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点："></a><strong>⚠️在 Dev-C++ 中出现中文“锟斤拷”或乱码，主要源自以下几点：</strong></h2><p>① 编辑器默认编码为 ANSI，与源文件或系统不匹配<br>② Console 窗口默认 Code Page 非 UTF-8，导致输出无法正确解码<br>③ 系统语言&#x2F;区域设置不当，可能影响文件打开与显示  </p><p>下面汇总几种常用且高效的解决方案，您可按需任选或组合使用。</p><hr><h2 id="①-更改编辑器默认编码"><a href="#①-更改编辑器默认编码" class="headerlink" title="① 更改编辑器默认编码"></a>① 更改编辑器默认编码</h2><p>a. 打开 Dev-C++，依次点击 <strong>Tools → Editor Options</strong>，在 <strong>General</strong>（或 <strong>Code Generation</strong>）选项卡中，将 <strong>Character set</strong> 从 <strong>ANSI</strong> 改为 <strong>UTF-8</strong> 并确认。<br>b. 关闭当前编辑的文件后重新打开，即可让编辑器以 UTF-8 模式加载和保存文件。</p><hr><h2 id="②-源文件另存为-UTF-8"><a href="#②-源文件另存为-UTF-8" class="headerlink" title="② 源文件另存为 UTF-8"></a>② 源文件另存为 UTF-8</h2><p>a. 在 Dev-C++ 中打开源文件，点击 <strong>File → Save As…</strong><br>b. 在保存对话框的编码选项中，选择 <strong>UTF-8</strong>（无 BOM）后保存。<br>c. 若批量转换，可使用 Notepad++：打开文件 → <strong>Encoding → Convert to UTF-8</strong> → 保存。</p><hr><h2 id="③-利用记事本或-Notepad-转码"><a href="#③-利用记事本或-Notepad-转码" class="headerlink" title="③ 利用记事本或 Notepad++ 转码"></a>③ 利用记事本或 Notepad++ 转码</h2><p>a. <strong>记事本法</strong>：  </p><ul><li>右键目标 <code>.cpp</code>&#x2F;<code>.h</code> 文件 → <strong>打开方式 → 记事本</strong>  </li><li>在记事本中点击 <strong>文件 → 另存为</strong>，选择 <strong>ANSI</strong> 编码保存（覆盖或另存）  </li><li>再用 Dev-C++ 打开，强制以 ANSI 读取，常能规避乱码</li></ul><p>b. <strong>Notepad++ 法</strong>：  </p><ul><li>用 Notepad++ 打开源码 → <strong>Encoding → Convert to UTF-8</strong>（注意非“Encode in UTF-8”）  </li><li>保存后再用 Dev-C++ 正常打开编译</li></ul><hr><h2 id="④-设置-Console-窗口编码"><a href="#④-设置-Console-窗口编码" class="headerlink" title="④ 设置 Console 窗口编码"></a>④ 设置 Console 窗口编码</h2><p>a. 在 Windows 控制台中手动切换：  </p><blockquote><p>chcp 65001</p></blockquote><p>   使当前会话使用 UTF-8 Code Page<br>b. 或修改注册表，永久生效：  </p><ul><li><p>打开 <strong>Regedit</strong>，定位到  </p><blockquote><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\Autorun</p></blockquote><p>新建&#x2F;修改字符串值为：  </p><blockquote><p>@chcp 65001&gt;nul</p></blockquote><p>以后每次打开控制台都会自动切换到 UTF-8</p></li></ul><hr><h2 id="⑤-在代码中显式设置"><a href="#⑤-在代码中显式设置" class="headerlink" title="⑤ 在代码中显式设置"></a>⑤ 在代码中显式设置</h2><p> 在程序入口处调用 Windows API：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="强制控制台以-UTF-8-解码输出"><a href="#强制控制台以-UTF-8-解码输出" class="headerlink" title="   强制控制台以 UTF-8 解码输出"></a>   强制控制台以 UTF-8 解码输出</h2><h2 id="⑥-检查系统语言与区域设置"><a href="#⑥-检查系统语言与区域设置" class="headerlink" title="⑥ 检查系统语言与区域设置"></a>⑥ 检查系统语言与区域设置</h2><p>a. 进入 <strong>控制面板 → 语言和区域设置 → 管理语言设置</strong><br>b. 将“非 Unicode 程序的语言”改为 <strong>中文（简体，中国）</strong>，重启生效<br>c. 确保系统区域、字体均支持中文显示</p><hr><blockquote><p>以上方法可单独或组合使用，通常先保证编辑器和源文件均为 UTF-8，再调整控制台 Code Page，即可彻底解决 Dev-C++ 中文乱码问题。</p></blockquote><hr><h1 id="✅Dev-C-使用方法："><a href="#✅Dev-C-使用方法：" class="headerlink" title="✅Dev-C++使用方法："></a>✅Dev-C++使用方法：</h1><h2 id="1-界面与工作区布局"><a href="#1-界面与工作区布局" class="headerlink" title="1. 界面与工作区布局"></a>1. 界面与工作区布局</h2><p><img src="https://raw.githubusercontent.com/Embarcadero/Dev-Cpp/master/Source/Images/screenshot800x600.png" alt="Dev-C++ 主界面示例"><br><em>图：Dev-C++ 典型代码编辑与输出窗口布局</em>  </p><ol><li><strong>代码编辑区</strong>：左侧显示项目文件树，右侧显示代码编辑窗口。您可以通过拖动标签页，自由切换不同文件。</li><li><strong>输出与调试区</strong>：底部集成 Console 窗口，运行、编译、调试的所有输出都会在此展示，支持清屏和滚动查看。</li><li><strong>工具栏与菜单</strong>：常用操作按钮集中于顶部，包括新建、打开、保存、编译、调试、运行等，鼠标悬停可查看快捷键提示。</li></ol><h2 id="2-项目管理与构建流程"><a href="#2-项目管理与构建流程" class="headerlink" title="2. 项目管理与构建流程"></a>2. 项目管理与构建流程</h2><h3 id="2-1-新建项目"><a href="#2-1-新建项目" class="headerlink" title="2.1 新建项目"></a>2.1 新建项目</h3><ol><li>打开 Dev-C++ 后，依次点击：</li></ol><blockquote><p>File → New → Project</p></blockquote><ol start="2"><li>在弹出的对话框中选择“Console Application”或“GUI Application”，按照向导填写项目名称与保存路径。</li></ol><h3 id="2-2-添加源文件、头文件"><a href="#2-2-添加源文件、头文件" class="headerlink" title="2.2 添加源文件、头文件"></a>2.2 添加源文件、头文件</h3><ul><li>在“Project”窗口右键项目名，选择 <strong>Add to Project → New File</strong>，即可创建新的 <code>.cpp</code> 或 <code>.h</code> 文件。</li><li>若想引入已有文件，则选择 <strong>Add to Project → Add Existing Item</strong>，浏览文件夹并选中即可。</li></ul><h3 id="2-3-编译与链接"><a href="#2-3-编译与链接" class="headerlink" title="2.3 编译与链接"></a>2.3 编译与链接</h3><ul><li>点击工具栏上的 <strong>Compile</strong> (编译) 按钮即可编译当前源文件。</li><li>点击 <strong>Run</strong> (运行) 按钮，Dev-C++ 会先自动编译并链接，然后在下方 Console 窗口中执行。</li><li>若需要只链接不运行，可在菜单中选择 <strong>Execute → Compile &amp; Run Options</strong>，取消“Run after compile”前的勾选。</li></ul><h2 id="3-高级调试技巧"><a href="#3-高级调试技巧" class="headerlink" title="3. 高级调试技巧"></a>3. 高级调试技巧</h2><p><img src="https://img.youtube.com/vi/R5zhpQW-MJk/maxresdefault.jpg" alt="调试断点与变量监视"><br><em>图：设置断点与在“Watches”窗口监视变量值</em></p><ol><li><strong>断点管理</strong>：在代码编辑区左侧行号栏单击，可新增&#x2F;删除断点。</li><li><strong>单步执行</strong>：使用 <strong>Step Into (F7)</strong>、<strong>Step Over (F8)</strong> 等功能逐行跟踪。</li><li><strong>变量监视</strong>：在“Watches”窗口右键 → <strong>Insert Watch</strong>，输入变量名，可动态观察其值变化。</li><li><strong>调用堆栈</strong>：在断点处暂停时，点击“Call Stack”选项卡查看函数调用顺序，快速定位问题源头。</li></ol><h2 id="4-插件与扩展：DevPaks-管理"><a href="#4-插件与扩展：DevPaks-管理" class="headerlink" title="4. 插件与扩展：DevPaks 管理"></a>4. 插件与扩展：DevPaks 管理</h2><ol><li>打开 <strong>Tools → Package Manager</strong>。</li><li>在“Available”选项卡中搜索并安装常用 DevPaks，如：<ul><li>`gtkmm-devpack`：GTK+ C++ 接口支持</li><li>`SDL2-devpack`：简单跨平台多媒体与游戏开发库</li><li>`mysql-devpack`：MySQL 数据库接口</li></ul></li><li>选中目标 DevPak，点击 <strong>Install</strong> 即可一键集成对应头文件和库。</li></ol><blockquote><p><strong>Tip</strong>：若官方仓库中未找到，您也可从 <a href="https://sourceforge.net/projects/devpaks/">SourceForge DevPaks 列表</a> 下载并安装。</p></blockquote><h2 id="5-性能优化与编译选项"><a href="#5-性能优化与编译选项" class="headerlink" title="5. 性能优化与编译选项"></a>5. 性能优化与编译选项</h2><ul><li><strong>Optimization level</strong> (<code>-O0</code>&#x2F;<code>-O1</code>&#x2F;<code>-O2</code>&#x2F;<code>-O3</code>): 开发阶段建议使用 <code>-O0</code> 便于调试；发布阶段可切换到 <code>-O2</code> 或 <code>-O3</code>，提升执行效率。</li><li><strong>Language standard</strong>：支持选择 <code>ISO C++11</code>、<code>ISO C++14</code>、<code>GNU C++17</code> 等，确保与现代编译特性兼容。</li><li><strong>Link-time optimization</strong> (LTO)：启用可在链接阶段进一步优化。</li></ul><h2 id="6-常见问题与解决方案"><a href="#6-常见问题与解决方案" class="headerlink" title="6. 常见问题与解决方案"></a>6. 常见问题与解决方案</h2><table><thead><tr><th>问题描述</th><th>解决方法</th></tr></thead><tbody><tr><td>编译时报 “cannot find -lmingw32”</td><td>检查 MinGW 路径：<code>Tools → Compiler Options → Directories → Libraries</code> 中添加 MinGW 安装目录下的 <code>lib</code></td></tr><tr><td>控制台汉字显示乱码</td><td>右键 Console → Properties → Font 选择 “新宋体” 或 “Consolas”，并确保文件以 UTF-8 编码保存</td></tr><tr><td>插件安装后 IDE 无法启动</td><td>删除 <code>%AppData%\\Dev-Cpp\\</code> 下的配置文件或重新安装对应 DevPak</td></tr><tr><td>调试时无法进入标准库函数</td><td>在 <strong>Project Options → Debugging</strong> 中勾选 “Debug Standard Libraries”</td></tr></tbody></table><h2 id="7-实战案例：使用-OpenCV-进行图像处理"><a href="#7-实战案例：使用-OpenCV-进行图像处理" class="headerlink" title="7. 实战案例：使用 OpenCV 进行图像处理"></a>7. 实战案例：使用 OpenCV 进行图像处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="built_in">imwrite</span>(<span class="string">&quot;output.jpg&quot;</span>, gray);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>安装 <code>opencv-devpack</code>。</li><li>新建 Console 项目，添加代码至 <code>main.cpp</code>。</li><li>链接参数：<code>-lopencv_core -lopencv_imgproc -lopencv_highgui</code>。</li><li>复制 OpenCV <code>bin</code> 下的 <code>.dll</code> 至可执行文件目录。</li><li>点击 <strong>Compile &amp; Run</strong>，查看生成的 <code>output.jpg</code>。</li></ol><h2 id="8-社区与学习资源"><a href="#8-社区与学习资源" class="headerlink" title="8. 社区与学习资源"></a>8. 社区与学习资源</h2><ul><li>官方论坛：Stack Overflow <a href="https://stackoverflow.com/questions/tagged/orwelldevcpp">orwelldevcpp</a></li><li>源码仓库:<a href="https://github.com/Embarcadero/Dev-Cpp">Embarcadero 官方托管（GitHub）</a></li><li>源码仓库:<a href="https://sourceforge.net/projects/orwelldevcpp/files/Source/">Orwell 版本源码快照（SourceForge）</a></li><li>书籍：《C++ Primer 中文版》、《Effective C++》系列、《OpenCV 图像处理实战》</li><li>视频教程：B站搜索“Dev-C++ 教程”</li></ul><h2 id="9-版本控制与协作"><a href="#9-版本控制与协作" class="headerlink" title="9. 版本控制与协作"></a>9. 版本控制与协作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用 Sourcetree、GitKraken 或命令行进行分支与合并管理。</li><li>通过 Pull Request 流程保证代码质量。</li></ul><h2 id="10-单元测试与质量保障"><a href="#10-单元测试与质量保障" class="headerlink" title="10. 单元测试与质量保障"></a>10. 单元测试与质量保障</h2><ul><li>安装 <code>gtest-devpack</code>，链接 <code>-lgtest -lgtest_main</code>。</li><li>示例测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="built_in">TEST</span>(MathTest, Add) &#123; <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span><span class="number">+3</span>,<span class="number">5</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>**argv)</span></span>&#123; testing::<span class="built_in">InitGoogleTest</span>(&amp;argc,argv); <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="11-静态分析与内存检测"><a href="#11-静态分析与内存检测" class="headerlink" title="11. 静态分析与内存检测"></a>11. 静态分析与内存检测</h2><ul><li><code>cppcheck --enable=all --inconclusive --std=c++17 src/</code></li><li>WSL&#x2F;Linux 下使用 <code>valgrind --leak-check=full ./your_executable</code></li></ul><h2 id="12-跨平台构建"><a href="#12-跨平台构建" class="headerlink" title="12. 跨平台构建"></a>12. 跨平台构建</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"><span class="keyword">add_executable</span>(MyApp main.cpp)</span><br></pre></td></tr></table></figure><ul><li>Windows 下 <code>cmake -G &quot;MinGW Makefiles&quot; . &amp;&amp; mingw32-make</code></li><li>WSL 下使用 Linux 编译链</li></ul><h2 id="13-自定义与自动化"><a href="#13-自定义与自动化" class="headerlink" title="13. 自定义与自动化"></a>13. 自定义与自动化</h2><h3 id="13-1-快捷键与宏"><a href="#13-1-快捷键与宏" class="headerlink" title="13.1 快捷键与宏"></a>13.1 快捷键与宏</h3><ul><li><strong>Tools → Editor Options → Keyboard</strong> 自定义快捷键</li><li><strong>Tools → Record Macro</strong> 录制并执行操作</li></ul><h3 id="13-2-构建脚本"><a href="#13-2-构建脚本" class="headerlink" title="13.2 构建脚本"></a>13.2 构建脚本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> /q bin\*</span><br><span class="line">devcpp.exe <span class="literal">-c</span> main.cpp <span class="literal">-o</span> bin\MyApp.exe</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="14-第三方插件与工具"><a href="#14-第三方插件与工具" class="headerlink" title="14. 第三方插件与工具"></a>14. 第三方插件与工具</h2><table><thead><tr><th>DevPak 名称</th><th>功能简介</th></tr></thead><tbody><tr><td>gtkmm-devpack</td><td>GTK+ C++ 图形界面支持</td></tr><tr><td>SDL2-devpack</td><td>跨平台多媒体与游戏开发</td></tr><tr><td>mysql-devpack</td><td>MySQL 数据库接口</td></tr><tr><td>boost-devpack</td><td>智能指针、正则等增强库</td></tr><tr><td>openssl-devpack</td><td>加密与安全通信支持</td></tr></tbody></table><p>可结合 Doxygen、ClangFormat、Bear 提升开发效率。</p><h2 id="15-安全注意事项"><a href="#15-安全注意事项" class="headerlink" title="15. 安全注意事项"></a>15. 安全注意事项</h2><ul><li>开启 <code>-fstack-protector-strong</code></li><li>严格边界检查，防止缓冲区溢出</li><li>发布开启 <code>-Wall -Wextra -Werror</code></li></ul><blockquote><p>本文从基础到高级全面覆盖 Dev-C++ 使用技巧与最佳实践，助您快速上手并精通。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PracticalTools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Dev-C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
